// Code generated by protoc-gen-gogo.
// source: account.proto
// DO NOT EDIT!

/*
	Package proto is a generated protocol buffer package.

	It is generated from these files:
		account.proto

	It has these top-level messages:
		CreditCard
		CreateCreditCardReq
		CreateCreditCardResp
		GetCreditCardReq
		GetCreditCardResp
		ListProductsReq
		ListProductsResp
		Product
		RatePlan
		PricingComponent
		PricingComponentTiers
		UnitOfMeasure
		ListInvoicesReq
		ListInvoicesResp
		GetInvoiceReq
		GetInvoiceResp
		Invoice
		GetInvoiceAsPDFReq
		GetInvoiceAsPDFResp
		CreateUserReq
		CreateUserResp
		GetUserReq
		GetUserResp
		ListAccountUsersReq
		ListAccountUsersResp
		InviteUserReq
		InviteUserResp
		AcceptUserInvitationReq
		AcceptUserInvitationResp
		AcceptAllUserInvitationsReq
		AcceptAllUserInvitationsResp
		RevokeUserAccountAccessReq
		ChangeUserRoleReq
		ChangeUserRoleResp
		RevokeUserAccountAccessResp
		GetAccountReq
		GetAccountResp
		ListAccountsReq
		ListAccountsResp
		CreateAccountReq
		CreateAccountResp
		UpdateProfileReq
		UpdateProfileResp
		CreateAddressReq
		CreateAddressResp
		UpdateAddressReq
		UpdateAddressResp
		UpsertAddressReq
		UpsertAddressResp
		RetireAccountReq
		UpsertAccountReq
		UpsertAccountResp
		RetireAccountResp
		ConvertExternallyCreatedAccountsReq
		ConvertExternallyCreatedAccountsResp
		Profile
		Address
		Account
		Subscription
		PricingComponentValue
		RoleValue
		User
		UserListUser
		PricingComponentQuantity
		CreateSubscriptionReq
		CreateSubscriptionResp
		CancelSubscriptionReq
		CancelSubscriptionResp
		UncancelSubscriptionReq
		UncancelSubscriptionResp
		ListSubscriptionsReq
		ListSubscriptionsResp
		SetQuayCredentialsReq
		SetQuayCredentialsResp
		GetQuayCredentialsReq
		GetQuayCredentialsResp
		GetAssetsReq
		GetAssetsResp
		Asset
		OutputFormat
		CreateLicenseReq
		CreateLicenseResp
		GetAccountStatusReq
		GetAccountStatusResp
		TerminateAccountReq
		TerminateAccountResp
		AdvanceAccountReq
		AdvanceAccountResp
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import common "github.com/coreos-inc/soy/proto/common"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import errors "errors"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto1.ProtoPackageIsVersion1

type StateSeverity int32

const (
	StateSeverity_UNKNOWN  StateSeverity = 0
	StateSeverity_NORMAL   StateSeverity = 1
	StateSeverity_GOOD     StateSeverity = 2
	StateSeverity_WARNING  StateSeverity = 3
	StateSeverity_CRITICAL StateSeverity = 4
)

var StateSeverity_name = map[int32]string{
	0: "UNKNOWN",
	1: "NORMAL",
	2: "GOOD",
	3: "WARNING",
	4: "CRITICAL",
}
var StateSeverity_value = map[string]int32{
	"UNKNOWN":  0,
	"NORMAL":   1,
	"GOOD":     2,
	"WARNING":  3,
	"CRITICAL": 4,
}

func (x StateSeverity) String() string {
	return proto1.EnumName(StateSeverity_name, int32(x))
}
func (StateSeverity) EnumDescriptor() ([]byte, []int) { return fileDescriptorAccount, []int{0} }

type Role int32

const (
	Role_READ_ONLY  Role = 0
	Role_ADMIN      Role = 1
	Role_SUPER_USER Role = 2
)

var Role_name = map[int32]string{
	0: "READ_ONLY",
	1: "ADMIN",
	2: "SUPER_USER",
}
var Role_value = map[string]int32{
	"READ_ONLY":  0,
	"ADMIN":      1,
	"SUPER_USER": 2,
}

func (x Role) String() string {
	return proto1.EnumName(Role_name, int32(x))
}
func (Role) EnumDescriptor() ([]byte, []int) { return fileDescriptorAccount, []int{1} }

type AssetType int32

const (
	AssetType_License    AssetType = 0
	AssetType_PullSecret AssetType = 1
)

var AssetType_name = map[int32]string{
	0: "License",
	1: "PullSecret",
}
var AssetType_value = map[string]int32{
	"License":    0,
	"PullSecret": 1,
}

func (x AssetType) String() string {
	return proto1.EnumName(AssetType_name, int32(x))
}
func (AssetType) EnumDescriptor() ([]byte, []int) { return fileDescriptorAccount, []int{2} }

type SubscriptionState int32

const (
	SubscriptionState_Provisioned     SubscriptionState = 0
	SubscriptionState_Paid            SubscriptionState = 1
	SubscriptionState_AwaitingPayment SubscriptionState = 2
	SubscriptionState_Cancelled       SubscriptionState = 3
	SubscriptionState_Failed          SubscriptionState = 4
	SubscriptionState_Expired         SubscriptionState = 5
)

var SubscriptionState_name = map[int32]string{
	0: "Provisioned",
	1: "Paid",
	2: "AwaitingPayment",
	3: "Cancelled",
	4: "Failed",
	5: "Expired",
}
var SubscriptionState_value = map[string]int32{
	"Provisioned":     0,
	"Paid":            1,
	"AwaitingPayment": 2,
	"Cancelled":       3,
	"Failed":          4,
	"Expired":         5,
}

func (x SubscriptionState) String() string {
	return proto1.EnumName(SubscriptionState_name, int32(x))
}
func (SubscriptionState) EnumDescriptor() ([]byte, []int) { return fileDescriptorAccount, []int{3} }

type CreditCard_CreditCardState int32

const (
	CreditCard_Pending  CreditCard_CreditCardState = 0
	CreditCard_Active   CreditCard_CreditCardState = 1
	CreditCard_Expired  CreditCard_CreditCardState = 2
	CreditCard_Expiring CreditCard_CreditCardState = 3
)

var CreditCard_CreditCardState_name = map[int32]string{
	0: "Pending",
	1: "Active",
	2: "Expired",
	3: "Expiring",
}
var CreditCard_CreditCardState_value = map[string]int32{
	"Pending":  0,
	"Active":   1,
	"Expired":  2,
	"Expiring": 3,
}

func (x CreditCard_CreditCardState) String() string {
	return proto1.EnumName(CreditCard_CreditCardState_name, int32(x))
}
func (CreditCard_CreditCardState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{0, 0}
}

type Subscription_PaymentType int32

const (
	Subscription_Unknown       Subscription_PaymentType = 0
	Subscription_PurchaseOrder Subscription_PaymentType = 1
	Subscription_CreditCard    Subscription_PaymentType = 2
	Subscription_None          Subscription_PaymentType = 3
)

var Subscription_PaymentType_name = map[int32]string{
	0: "Unknown",
	1: "PurchaseOrder",
	2: "CreditCard",
	3: "None",
}
var Subscription_PaymentType_value = map[string]int32{
	"Unknown":       0,
	"PurchaseOrder": 1,
	"CreditCard":    2,
	"None":          3,
}

func (x Subscription_PaymentType) String() string {
	return proto1.EnumName(Subscription_PaymentType_name, int32(x))
}
func (Subscription_PaymentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{58, 0}
}

type Subscription_SubscriptionType int32

const (
	Subscription_Trial        Subscription_SubscriptionType = 0
	Subscription_Subscription Subscription_SubscriptionType = 1
	Subscription_FixedTerm    Subscription_SubscriptionType = 2
)

var Subscription_SubscriptionType_name = map[int32]string{
	0: "Trial",
	1: "Subscription",
	2: "FixedTerm",
}
var Subscription_SubscriptionType_value = map[string]int32{
	"Trial":        0,
	"Subscription": 1,
	"FixedTerm":    2,
}

func (x Subscription_SubscriptionType) String() string {
	return proto1.EnumName(Subscription_SubscriptionType_name, int32(x))
}
func (Subscription_SubscriptionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{58, 1}
}

type CreateSubscriptionReq_PaymentType int32

const (
	CreateSubscriptionReq_PurchaseOrder CreateSubscriptionReq_PaymentType = 0
	CreateSubscriptionReq_CreditCard    CreateSubscriptionReq_PaymentType = 1
	CreateSubscriptionReq_None          CreateSubscriptionReq_PaymentType = 2
)

var CreateSubscriptionReq_PaymentType_name = map[int32]string{
	0: "PurchaseOrder",
	1: "CreditCard",
	2: "None",
}
var CreateSubscriptionReq_PaymentType_value = map[string]int32{
	"PurchaseOrder": 0,
	"CreditCard":    1,
	"None":          2,
}

func (x CreateSubscriptionReq_PaymentType) String() string {
	return proto1.EnumName(CreateSubscriptionReq_PaymentType_name, int32(x))
}
func (CreateSubscriptionReq_PaymentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{64, 0}
}

type GetAccountStatusResp_AccountStatus int32

const (
	GetAccountStatusResp_GOOD             GetAccountStatusResp_AccountStatus = 0
	GetAccountStatusResp_AWAITING_PAYMENT GetAccountStatusResp_AccountStatus = 1
	GetAccountStatusResp_DELINQUENT       GetAccountStatusResp_AccountStatus = 2
)

var GetAccountStatusResp_AccountStatus_name = map[int32]string{
	0: "GOOD",
	1: "AWAITING_PAYMENT",
	2: "DELINQUENT",
}
var GetAccountStatusResp_AccountStatus_value = map[string]int32{
	"GOOD":             0,
	"AWAITING_PAYMENT": 1,
	"DELINQUENT":       2,
}

func (x GetAccountStatusResp_AccountStatus) String() string {
	return proto1.EnumName(GetAccountStatusResp_AccountStatus_name, int32(x))
}
func (GetAccountStatusResp_AccountStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{83, 0}
}

type CreditCard struct {
	ID               string                     `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	AccountID        string                     `protobuf:"bytes,2,opt,name=account_id,json=accountId,proto3" json:"id"`
	LastFour         string                     `protobuf:"bytes,3,opt,name=last_four,json=lastFour,proto3" json:"lastFour"`
	ExpiryMonth      int32                      `protobuf:"varint,4,opt,name=expiry_month,json=expiryMonth,proto3" json:"expiryMonth"`
	ExpiryYear       int32                      `protobuf:"varint,5,opt,name=expiry_year,json=expiryYear,proto3" json:"expiryYear"`
	Type             string                     `protobuf:"bytes,6,opt,name=type,proto3" json:"type"`
	State            CreditCard_CreditCardState `protobuf:"varint,7,opt,name=state,proto3,enum=proto.CreditCard_CreditCardState" json:"state"`
	StateDescription string                     `protobuf:"bytes,8,opt,name=state_description,json=stateDescription,proto3" json:"stateDescription"`
}

func (m *CreditCard) Reset()                    { *m = CreditCard{} }
func (m *CreditCard) String() string            { return proto1.CompactTextString(m) }
func (*CreditCard) ProtoMessage()               {}
func (*CreditCard) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{0} }

type CreateCreditCardReq struct {
	Token     string `protobuf:"bytes,1,opt,name=token,proto3" json:"token"`
	AccountID string `protobuf:"bytes,2,opt,name=account_id,json=accountId,proto3" json:"accountID"`
}

func (m *CreateCreditCardReq) Reset()                    { *m = CreateCreditCardReq{} }
func (m *CreateCreditCardReq) String() string            { return proto1.CompactTextString(m) }
func (*CreateCreditCardReq) ProtoMessage()               {}
func (*CreateCreditCardReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{1} }

type CreateCreditCardResp struct {
	Card *CreditCard `protobuf:"bytes,1,opt,name=card" json:"card"`
}

func (m *CreateCreditCardResp) Reset()                    { *m = CreateCreditCardResp{} }
func (m *CreateCreditCardResp) String() string            { return proto1.CompactTextString(m) }
func (*CreateCreditCardResp) ProtoMessage()               {}
func (*CreateCreditCardResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{2} }

func (m *CreateCreditCardResp) GetCard() *CreditCard {
	if m != nil {
		return m.Card
	}
	return nil
}

type GetCreditCardReq struct {
	AccountID string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"id"`
}

func (m *GetCreditCardReq) Reset()                    { *m = GetCreditCardReq{} }
func (m *GetCreditCardReq) String() string            { return proto1.CompactTextString(m) }
func (*GetCreditCardReq) ProtoMessage()               {}
func (*GetCreditCardReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{3} }

type GetCreditCardResp struct {
	Card *CreditCard `protobuf:"bytes,1,opt,name=card" json:"card"`
}

func (m *GetCreditCardResp) Reset()                    { *m = GetCreditCardResp{} }
func (m *GetCreditCardResp) String() string            { return proto1.CompactTextString(m) }
func (*GetCreditCardResp) ProtoMessage()               {}
func (*GetCreditCardResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{4} }

func (m *GetCreditCardResp) GetCard() *CreditCard {
	if m != nil {
		return m.Card
	}
	return nil
}

type ListProductsReq struct {
	IncludeDeleted bool `protobuf:"varint,1,opt,name=include_deleted,json=includeDeleted,proto3" json:"includeDeleted"`
	IncludePrivate bool `protobuf:"varint,2,opt,name=include_private,json=includePrivate,proto3" json:"includePrivate"`
}

func (m *ListProductsReq) Reset()                    { *m = ListProductsReq{} }
func (m *ListProductsReq) String() string            { return proto1.CompactTextString(m) }
func (*ListProductsReq) ProtoMessage()               {}
func (*ListProductsReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{5} }

type ListProductsResp struct {
	Items []*Product `protobuf:"bytes,1,rep,name=items" json:"items"`
}

func (m *ListProductsResp) Reset()                    { *m = ListProductsResp{} }
func (m *ListProductsResp) String() string            { return proto1.CompactTextString(m) }
func (*ListProductsResp) ProtoMessage()               {}
func (*ListProductsResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{6} }

func (m *ListProductsResp) GetItems() []*Product {
	if m != nil {
		return m.Items
	}
	return nil
}

type Product struct {
	ID             string      `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name           string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	PublicName     string      `protobuf:"bytes,3,opt,name=public_name,json=publicName,proto3" json:"publicName"`
	Description    string      `protobuf:"bytes,4,opt,name=description,proto3" json:"description"`
	Duration       int32       `protobuf:"varint,7,opt,name=duration,proto3" json:"duration"`
	DurationPeriod string      `protobuf:"bytes,8,opt,name=duration_period,json=durationPeriod,proto3" json:"durationPeriod"`
	Trial          int32       `protobuf:"varint,9,opt,name=trial,proto3" json:"trial"`
	TrialPeriod    string      `protobuf:"bytes,10,opt,name=trial_period,json=trialPeriod,proto3" json:"trialPeriod"`
	ProductType    string      `protobuf:"bytes,11,opt,name=product_type,json=productType,proto3" json:"productType"`
	Deleted        bool        `protobuf:"varint,12,opt,name=deleted,proto3" json:"deleted"`
	Public         bool        `protobuf:"varint,13,opt,name=public,proto3" json:"public"`
	ExternalLink   string      `protobuf:"bytes,14,opt,name=external_link,json=externalLink,proto3" json:"externalLink"`
	TOSLink        string      `protobuf:"bytes,15,opt,name=tos_link,json=tosLink,proto3" json:"tosLink"`
	QuickstartLink string      `protobuf:"bytes,16,opt,name=quickstart_link,json=quickstartLink,proto3" json:"quickstartLink"`
	Order          int32       `protobuf:"varint,17,opt,name=order,proto3" json:"order"`
	RatePlans      []*RatePlan `protobuf:"bytes,18,rep,name=rate_plans,json=ratePlans" json:"ratePlans"`
}

func (m *Product) Reset()                    { *m = Product{} }
func (m *Product) String() string            { return proto1.CompactTextString(m) }
func (*Product) ProtoMessage()               {}
func (*Product) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{7} }

func (m *Product) GetRatePlans() []*RatePlan {
	if m != nil {
		return m.RatePlans
	}
	return nil
}

type RatePlan struct {
	ID                        string              `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                      string              `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	PublicName                string              `protobuf:"bytes,3,opt,name=public_name,json=publicName,proto3" json:"publicName"`
	Description               string              `protobuf:"bytes,4,opt,name=description,proto3" json:"description"`
	Duration                  int32               `protobuf:"varint,5,opt,name=duration,proto3" json:"duration"`
	DurationPeriod            string              `protobuf:"bytes,6,opt,name=duration_period,json=durationPeriod,proto3" json:"durationPeriod"`
	Trial                     int32               `protobuf:"varint,7,opt,name=trial,proto3" json:"trial"`
	TrialPeriod               string              `protobuf:"bytes,8,opt,name=trial_period,json=trialPeriod,proto3" json:"trialPeriod"`
	Public                    bool                `protobuf:"varint,9,opt,name=public,proto3" json:"public"`
	Purchasable               bool                `protobuf:"varint,10,opt,name=purchasable,proto3" json:"purchasable"`
	ProductID                 string              `protobuf:"bytes,11,opt,name=product_id,json=productId,proto3" json:"productID"`
	BypassPaymentVerification bool                `protobuf:"varint,12,opt,name=bypass_payment_verification,json=bypassPaymentVerification,proto3" json:"bypassPaymentVerification"`
	Order                     int32               `protobuf:"varint,13,opt,name=order,proto3" json:"order"`
	PricingComponents         []*PricingComponent `protobuf:"bytes,14,rep,name=pricing_components,json=pricingComponents" json:"pricingComponents"`
	QuayTeams                 []string            `protobuf:"bytes,15,rep,name=quay_teams,json=quayTeams" json:"quayTeams"`
	FailedPaymentBehaviour    string              `protobuf:"bytes,16,opt,name=failed_payment_behaviour,json=failedPaymentBehaviour,proto3" json:"failedPaymentBehaviour"`
}

func (m *RatePlan) Reset()                    { *m = RatePlan{} }
func (m *RatePlan) String() string            { return proto1.CompactTextString(m) }
func (*RatePlan) ProtoMessage()               {}
func (*RatePlan) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{8} }

func (m *RatePlan) GetPricingComponents() []*PricingComponent {
	if m != nil {
		return m.PricingComponents
	}
	return nil
}

type PricingComponent struct {
	Type            string                   `protobuf:"bytes,1,opt,name=type,proto3" json:"@type"`
	ID              string                   `protobuf:"bytes,2,opt,name=id,proto3" json:"id"`
	Name            string                   `protobuf:"bytes,3,opt,name=name,proto3" json:"name"`
	PublicName      string                   `protobuf:"bytes,4,opt,name=public_name,json=publicName,proto3" json:"publicName"`
	Description     string                   `protobuf:"bytes,5,opt,name=description,proto3" json:"description"`
	DefaultQuantity int64                    `protobuf:"varint,6,opt,name=default_quantity,json=defaultQuantity,proto3" json:"defaultQuantity"`
	MinQuantity     int64                    `protobuf:"varint,7,opt,name=min_quantity,json=minQuantity,proto3" json:"minQuantity"`
	Tiers           []*PricingComponentTiers `protobuf:"bytes,8,rep,name=tiers" json:"tiers"`
	UnitOfMeasure   *UnitOfMeasure           `protobuf:"bytes,9,opt,name=unit_of_measure,json=unitOfMeasure" json:"unitOfMeasure"`
}

func (m *PricingComponent) Reset()                    { *m = PricingComponent{} }
func (m *PricingComponent) String() string            { return proto1.CompactTextString(m) }
func (*PricingComponent) ProtoMessage()               {}
func (*PricingComponent) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{9} }

func (m *PricingComponent) GetTiers() []*PricingComponentTiers {
	if m != nil {
		return m.Tiers
	}
	return nil
}

func (m *PricingComponent) GetUnitOfMeasure() *UnitOfMeasure {
	if m != nil {
		return m.UnitOfMeasure
	}
	return nil
}

type PricingComponentTiers struct {
	ID             string  `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	LowerThreshold int64   `protobuf:"varint,2,opt,name=lower_threshold,json=lowerThreshold,proto3" json:"lowerThreshold"`
	UpperThreshold int64   `protobuf:"varint,3,opt,name=upper_threshold,json=upperThreshold,proto3" json:"upperThreshold"`
	PricingType    string  `protobuf:"bytes,4,opt,name=pricing_type,json=pricingType,proto3" json:"pricingType"`
	Price          float64 `protobuf:"fixed64,5,opt,name=price,proto3" json:"price"`
}

func (m *PricingComponentTiers) Reset()                    { *m = PricingComponentTiers{} }
func (m *PricingComponentTiers) String() string            { return proto1.CompactTextString(m) }
func (*PricingComponentTiers) ProtoMessage()               {}
func (*PricingComponentTiers) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{10} }

type UnitOfMeasure struct {
	ID          string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name        string `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	DisplayedAs string `protobuf:"bytes,3,opt,name=displayed_as,json=displayedAs,proto3" json:"displayedAs"`
}

func (m *UnitOfMeasure) Reset()                    { *m = UnitOfMeasure{} }
func (m *UnitOfMeasure) String() string            { return proto1.CompactTextString(m) }
func (*UnitOfMeasure) ProtoMessage()               {}
func (*UnitOfMeasure) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{11} }

type ListInvoicesReq struct {
	AccountID string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
}

func (m *ListInvoicesReq) Reset()                    { *m = ListInvoicesReq{} }
func (m *ListInvoicesReq) String() string            { return proto1.CompactTextString(m) }
func (*ListInvoicesReq) ProtoMessage()               {}
func (*ListInvoicesReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{12} }

type ListInvoicesResp struct {
	Invoices []*Invoice `protobuf:"bytes,1,rep,name=invoices" json:"invoices,omitempty"`
}

func (m *ListInvoicesResp) Reset()                    { *m = ListInvoicesResp{} }
func (m *ListInvoicesResp) String() string            { return proto1.CompactTextString(m) }
func (*ListInvoicesResp) ProtoMessage()               {}
func (*ListInvoicesResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{13} }

func (m *ListInvoicesResp) GetInvoices() []*Invoice {
	if m != nil {
		return m.Invoices
	}
	return nil
}

type GetInvoiceReq struct {
	InvoiceID string `protobuf:"bytes,1,opt,name=invoice_id,json=invoiceId,proto3" json:"invoice_id"`
}

func (m *GetInvoiceReq) Reset()                    { *m = GetInvoiceReq{} }
func (m *GetInvoiceReq) String() string            { return proto1.CompactTextString(m) }
func (*GetInvoiceReq) ProtoMessage()               {}
func (*GetInvoiceReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{14} }

type GetInvoiceResp struct {
	Invoice *Invoice `protobuf:"bytes,1,opt,name=invoice" json:"invoice,omitempty"`
}

func (m *GetInvoiceResp) Reset()                    { *m = GetInvoiceResp{} }
func (m *GetInvoiceResp) String() string            { return proto1.CompactTextString(m) }
func (*GetInvoiceResp) ProtoMessage()               {}
func (*GetInvoiceResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{15} }

func (m *GetInvoiceResp) GetInvoice() *Invoice {
	if m != nil {
		return m.Invoice
	}
	return nil
}

type Invoice struct {
	ID                     string  `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                   string  `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	SubscriptionID         string  `protobuf:"bytes,3,opt,name=subscription_id,json=subscriptionId,proto3" json:"subscriptionID"`
	AccountID              string  `protobuf:"bytes,4,opt,name=account_id,json=accountId,proto3" json:"accountID"`
	Type                   string  `protobuf:"bytes,5,opt,name=type,proto3" json:"type,omitempty"`
	State                  string  `protobuf:"bytes,6,opt,name=state,proto3" json:"state,omitempty"`
	PeriodStart            string  `protobuf:"bytes,7,opt,name=period_start,json=periodStart,proto3" json:"periodStart"`
	PeriodEnd              string  `protobuf:"bytes,8,opt,name=period_end,json=periodEnd,proto3" json:"periodEnd"`
	Issued                 string  `protobuf:"bytes,9,opt,name=issued,proto3" json:"issued,omitempty"`
	InvoiceCost            float64 `protobuf:"fixed64,10,opt,name=invoice_cost,json=invoiceCost,proto3" json:"invoiceCost"`
	InvoicePaid            float64 `protobuf:"fixed64,11,opt,name=invoice_paid,json=invoicePaid,proto3" json:"invoicePaid"`
	DiscountAmount         float64 `protobuf:"fixed64,12,opt,name=discount_amount,json=discountAmount,proto3" json:"discountAmount"`
	NonDiscountedCost      float64 `protobuf:"fixed64,13,opt,name=non_discounted_cost,json=nonDiscountedCost,proto3" json:"nonDiscountedCost"`
	PaymentReceived        string  `protobuf:"bytes,14,opt,name=payment_received,json=paymentReceived,proto3" json:"paymentReceived"`
	InitialInvoice         bool    `protobuf:"varint,15,opt,name=initial_invoice,json=initialInvoice,proto3" json:"initialInvoice"`
	TotalExecutionAttempts int32   `protobuf:"varint,16,opt,name=total_execution_attempts,json=totalExecutionAttempts,proto3" json:"totalExecutionAttempts"`
	Currency               string  `protobuf:"bytes,17,opt,name=currency,proto3" json:"currency,omitempty"`
}

func (m *Invoice) Reset()                    { *m = Invoice{} }
func (m *Invoice) String() string            { return proto1.CompactTextString(m) }
func (*Invoice) ProtoMessage()               {}
func (*Invoice) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{16} }

type GetInvoiceAsPDFReq struct {
	InvoiceID string `protobuf:"bytes,1,opt,name=invoice_id,json=invoiceId,proto3" json:"invoiceID"`
}

func (m *GetInvoiceAsPDFReq) Reset()                    { *m = GetInvoiceAsPDFReq{} }
func (m *GetInvoiceAsPDFReq) String() string            { return proto1.CompactTextString(m) }
func (*GetInvoiceAsPDFReq) ProtoMessage()               {}
func (*GetInvoiceAsPDFReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{17} }

type GetInvoiceAsPDFResp struct {
	InvoiceData []byte `protobuf:"bytes,1,opt,name=invoice_data,json=invoiceData,proto3" json:"invoice_data,omitempty"`
}

func (m *GetInvoiceAsPDFResp) Reset()                    { *m = GetInvoiceAsPDFResp{} }
func (m *GetInvoiceAsPDFResp) String() string            { return proto1.CompactTextString(m) }
func (*GetInvoiceAsPDFResp) ProtoMessage()               {}
func (*GetInvoiceAsPDFResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{18} }

type CreateUserReq struct {
	DexID string `protobuf:"bytes,1,opt,name=dex_id,json=dexId,proto3" json:"dexID"`
	Email string `protobuf:"bytes,2,opt,name=email,proto3" json:"email"`
}

func (m *CreateUserReq) Reset()                    { *m = CreateUserReq{} }
func (m *CreateUserReq) String() string            { return proto1.CompactTextString(m) }
func (*CreateUserReq) ProtoMessage()               {}
func (*CreateUserReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{19} }

type CreateUserResp struct {
	User *User `protobuf:"bytes,1,opt,name=user" json:"user"`
}

func (m *CreateUserResp) Reset()                    { *m = CreateUserResp{} }
func (m *CreateUserResp) String() string            { return proto1.CompactTextString(m) }
func (*CreateUserResp) ProtoMessage()               {}
func (*CreateUserResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{20} }

func (m *CreateUserResp) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

type GetUserReq struct {
	DexID string `protobuf:"bytes,1,opt,name=dex_id,json=dexId,proto3" json:"dexID"`
}

func (m *GetUserReq) Reset()                    { *m = GetUserReq{} }
func (m *GetUserReq) String() string            { return proto1.CompactTextString(m) }
func (*GetUserReq) ProtoMessage()               {}
func (*GetUserReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{21} }

type GetUserResp struct {
	User *User `protobuf:"bytes,1,opt,name=user" json:"user"`
}

func (m *GetUserResp) Reset()                    { *m = GetUserResp{} }
func (m *GetUserResp) String() string            { return proto1.CompactTextString(m) }
func (*GetUserResp) ProtoMessage()               {}
func (*GetUserResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{22} }

func (m *GetUserResp) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

type ListAccountUsersReq struct {
	AccountID string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"accountID"`
}

func (m *ListAccountUsersReq) Reset()                    { *m = ListAccountUsersReq{} }
func (m *ListAccountUsersReq) String() string            { return proto1.CompactTextString(m) }
func (*ListAccountUsersReq) ProtoMessage()               {}
func (*ListAccountUsersReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{23} }

type ListAccountUsersResp struct {
	Items []*UserListUser `protobuf:"bytes,1,rep,name=items" json:"items"`
}

func (m *ListAccountUsersResp) Reset()                    { *m = ListAccountUsersResp{} }
func (m *ListAccountUsersResp) String() string            { return proto1.CompactTextString(m) }
func (*ListAccountUsersResp) ProtoMessage()               {}
func (*ListAccountUsersResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{24} }

func (m *ListAccountUsersResp) GetItems() []*UserListUser {
	if m != nil {
		return m.Items
	}
	return nil
}

type InviteUserReq struct {
	Email     string `protobuf:"bytes,1,opt,name=email,proto3" json:"email"`
	AccountID string `protobuf:"bytes,2,opt,name=account_id,json=accountId,proto3" json:"accountID"`
	Role      Role   `protobuf:"varint,3,opt,name=role,proto3,enum=proto.Role" json:"role,omitempty"`
}

func (m *InviteUserReq) Reset()                    { *m = InviteUserReq{} }
func (m *InviteUserReq) String() string            { return proto1.CompactTextString(m) }
func (*InviteUserReq) ProtoMessage()               {}
func (*InviteUserReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{25} }

type InviteUserResp struct {
}

func (m *InviteUserResp) Reset()                    { *m = InviteUserResp{} }
func (m *InviteUserResp) String() string            { return proto1.CompactTextString(m) }
func (*InviteUserResp) ProtoMessage()               {}
func (*InviteUserResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{26} }

type AcceptUserInvitationReq struct {
	AccountID string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"accountID"`
}

func (m *AcceptUserInvitationReq) Reset()                    { *m = AcceptUserInvitationReq{} }
func (m *AcceptUserInvitationReq) String() string            { return proto1.CompactTextString(m) }
func (*AcceptUserInvitationReq) ProtoMessage()               {}
func (*AcceptUserInvitationReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{27} }

type AcceptUserInvitationResp struct {
}

func (m *AcceptUserInvitationResp) Reset()                    { *m = AcceptUserInvitationResp{} }
func (m *AcceptUserInvitationResp) String() string            { return proto1.CompactTextString(m) }
func (*AcceptUserInvitationResp) ProtoMessage()               {}
func (*AcceptUserInvitationResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{28} }

type AcceptAllUserInvitationsReq struct {
	DexID string `protobuf:"bytes,1,opt,name=dex_id,json=dexId,proto3" json:"dexID"`
}

func (m *AcceptAllUserInvitationsReq) Reset()         { *m = AcceptAllUserInvitationsReq{} }
func (m *AcceptAllUserInvitationsReq) String() string { return proto1.CompactTextString(m) }
func (*AcceptAllUserInvitationsReq) ProtoMessage()    {}
func (*AcceptAllUserInvitationsReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{29}
}

type AcceptAllUserInvitationsResp struct {
}

func (m *AcceptAllUserInvitationsResp) Reset()         { *m = AcceptAllUserInvitationsResp{} }
func (m *AcceptAllUserInvitationsResp) String() string { return proto1.CompactTextString(m) }
func (*AcceptAllUserInvitationsResp) ProtoMessage()    {}
func (*AcceptAllUserInvitationsResp) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{30}
}

type RevokeUserAccountAccessReq struct {
	// Dex id of a user who is *already* associated with an account.
	ExistingMemberDexID string `protobuf:"bytes,1,opt,name=existing_member_dex_id,json=existingMemberDexId,proto3" json:"existingUserDexID"`
	// Email of a user who has been *invited* to an account.
	InvitedUserEmail string `protobuf:"bytes,2,opt,name=invited_user_email,json=invitedUserEmail,proto3" json:"invitedUserEmail"`
	// account_id is the billforward account # the user/invited user belongs to.
	AccountID string `protobuf:"bytes,3,opt,name=account_id,json=accountId,proto3" json:"accountID"`
}

func (m *RevokeUserAccountAccessReq) Reset()         { *m = RevokeUserAccountAccessReq{} }
func (m *RevokeUserAccountAccessReq) String() string { return proto1.CompactTextString(m) }
func (*RevokeUserAccountAccessReq) ProtoMessage()    {}
func (*RevokeUserAccountAccessReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{31}
}

type ChangeUserRoleReq struct {
	DexID     string `protobuf:"bytes,1,opt,name=dex_id,json=dexId,proto3" json:"dexID"`
	AccountID string `protobuf:"bytes,2,opt,name=account_id,json=accountId,proto3" json:"accountID"`
	Role      Role   `protobuf:"varint,3,opt,name=role,proto3,enum=proto.Role" json:"role,omitempty"`
}

func (m *ChangeUserRoleReq) Reset()                    { *m = ChangeUserRoleReq{} }
func (m *ChangeUserRoleReq) String() string            { return proto1.CompactTextString(m) }
func (*ChangeUserRoleReq) ProtoMessage()               {}
func (*ChangeUserRoleReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{32} }

type ChangeUserRoleResp struct {
}

func (m *ChangeUserRoleResp) Reset()                    { *m = ChangeUserRoleResp{} }
func (m *ChangeUserRoleResp) String() string            { return proto1.CompactTextString(m) }
func (*ChangeUserRoleResp) ProtoMessage()               {}
func (*ChangeUserRoleResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{33} }

type RevokeUserAccountAccessResp struct {
}

func (m *RevokeUserAccountAccessResp) Reset()         { *m = RevokeUserAccountAccessResp{} }
func (m *RevokeUserAccountAccessResp) String() string { return proto1.CompactTextString(m) }
func (*RevokeUserAccountAccessResp) ProtoMessage()    {}
func (*RevokeUserAccountAccessResp) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{34}
}

type GetAccountReq struct {
	AccountID string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"accountID"`
}

func (m *GetAccountReq) Reset()                    { *m = GetAccountReq{} }
func (m *GetAccountReq) String() string            { return proto1.CompactTextString(m) }
func (*GetAccountReq) ProtoMessage()               {}
func (*GetAccountReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{35} }

type GetAccountResp struct {
	Account       *Account        `protobuf:"bytes,1,opt,name=account" json:"account"`
	Subscriptions []*Subscription `protobuf:"bytes,2,rep,name=subscriptions" json:"subscriptions"`
}

func (m *GetAccountResp) Reset()                    { *m = GetAccountResp{} }
func (m *GetAccountResp) String() string            { return proto1.CompactTextString(m) }
func (*GetAccountResp) ProtoMessage()               {}
func (*GetAccountResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{36} }

func (m *GetAccountResp) GetAccount() *Account {
	if m != nil {
		return m.Account
	}
	return nil
}

func (m *GetAccountResp) GetSubscriptions() []*Subscription {
	if m != nil {
		return m.Subscriptions
	}
	return nil
}

type ListAccountsReq struct {
}

func (m *ListAccountsReq) Reset()                    { *m = ListAccountsReq{} }
func (m *ListAccountsReq) String() string            { return proto1.CompactTextString(m) }
func (*ListAccountsReq) ProtoMessage()               {}
func (*ListAccountsReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{37} }

type ListAccountsResp struct {
	Items []*Account `protobuf:"bytes,1,rep,name=items" json:"items"`
}

func (m *ListAccountsResp) Reset()                    { *m = ListAccountsResp{} }
func (m *ListAccountsResp) String() string            { return proto1.CompactTextString(m) }
func (*ListAccountsResp) ProtoMessage()               {}
func (*ListAccountsResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{38} }

func (m *ListAccountsResp) GetItems() []*Account {
	if m != nil {
		return m.Items
	}
	return nil
}

type CreateAccountReq struct {
	Account *Account `protobuf:"bytes,1,opt,name=account" json:"account"`
}

func (m *CreateAccountReq) Reset()                    { *m = CreateAccountReq{} }
func (m *CreateAccountReq) String() string            { return proto1.CompactTextString(m) }
func (*CreateAccountReq) ProtoMessage()               {}
func (*CreateAccountReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{39} }

func (m *CreateAccountReq) GetAccount() *Account {
	if m != nil {
		return m.Account
	}
	return nil
}

type CreateAccountResp struct {
	Account *Account `protobuf:"bytes,1,opt,name=account" json:"account"`
}

func (m *CreateAccountResp) Reset()                    { *m = CreateAccountResp{} }
func (m *CreateAccountResp) String() string            { return proto1.CompactTextString(m) }
func (*CreateAccountResp) ProtoMessage()               {}
func (*CreateAccountResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{40} }

func (m *CreateAccountResp) GetAccount() *Account {
	if m != nil {
		return m.Account
	}
	return nil
}

type UpdateProfileReq struct {
	Profile *Profile `protobuf:"bytes,1,opt,name=profile" json:"profile,omitempty"`
}

func (m *UpdateProfileReq) Reset()                    { *m = UpdateProfileReq{} }
func (m *UpdateProfileReq) String() string            { return proto1.CompactTextString(m) }
func (*UpdateProfileReq) ProtoMessage()               {}
func (*UpdateProfileReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{41} }

func (m *UpdateProfileReq) GetProfile() *Profile {
	if m != nil {
		return m.Profile
	}
	return nil
}

type UpdateProfileResp struct {
	Profile *Profile `protobuf:"bytes,1,opt,name=profile" json:"profile"`
}

func (m *UpdateProfileResp) Reset()                    { *m = UpdateProfileResp{} }
func (m *UpdateProfileResp) String() string            { return proto1.CompactTextString(m) }
func (*UpdateProfileResp) ProtoMessage()               {}
func (*UpdateProfileResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{42} }

func (m *UpdateProfileResp) GetProfile() *Profile {
	if m != nil {
		return m.Profile
	}
	return nil
}

type CreateAddressReq struct {
	Address *Address `protobuf:"bytes,1,opt,name=address" json:"address"`
}

func (m *CreateAddressReq) Reset()                    { *m = CreateAddressReq{} }
func (m *CreateAddressReq) String() string            { return proto1.CompactTextString(m) }
func (*CreateAddressReq) ProtoMessage()               {}
func (*CreateAddressReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{43} }

func (m *CreateAddressReq) GetAddress() *Address {
	if m != nil {
		return m.Address
	}
	return nil
}

type CreateAddressResp struct {
	Address *Address `protobuf:"bytes,1,opt,name=address" json:"address"`
}

func (m *CreateAddressResp) Reset()                    { *m = CreateAddressResp{} }
func (m *CreateAddressResp) String() string            { return proto1.CompactTextString(m) }
func (*CreateAddressResp) ProtoMessage()               {}
func (*CreateAddressResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{44} }

func (m *CreateAddressResp) GetAddress() *Address {
	if m != nil {
		return m.Address
	}
	return nil
}

type UpdateAddressReq struct {
	Address *Address `protobuf:"bytes,1,opt,name=address" json:"address"`
}

func (m *UpdateAddressReq) Reset()                    { *m = UpdateAddressReq{} }
func (m *UpdateAddressReq) String() string            { return proto1.CompactTextString(m) }
func (*UpdateAddressReq) ProtoMessage()               {}
func (*UpdateAddressReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{45} }

func (m *UpdateAddressReq) GetAddress() *Address {
	if m != nil {
		return m.Address
	}
	return nil
}

type UpdateAddressResp struct {
	Address *Address `protobuf:"bytes,1,opt,name=address" json:"address"`
}

func (m *UpdateAddressResp) Reset()                    { *m = UpdateAddressResp{} }
func (m *UpdateAddressResp) String() string            { return proto1.CompactTextString(m) }
func (*UpdateAddressResp) ProtoMessage()               {}
func (*UpdateAddressResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{46} }

func (m *UpdateAddressResp) GetAddress() *Address {
	if m != nil {
		return m.Address
	}
	return nil
}

type UpsertAddressReq struct {
	Address *Address `protobuf:"bytes,1,opt,name=address" json:"address"`
}

func (m *UpsertAddressReq) Reset()                    { *m = UpsertAddressReq{} }
func (m *UpsertAddressReq) String() string            { return proto1.CompactTextString(m) }
func (*UpsertAddressReq) ProtoMessage()               {}
func (*UpsertAddressReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{47} }

func (m *UpsertAddressReq) GetAddress() *Address {
	if m != nil {
		return m.Address
	}
	return nil
}

type UpsertAddressResp struct {
	Address *Address `protobuf:"bytes,1,opt,name=address" json:"address"`
}

func (m *UpsertAddressResp) Reset()                    { *m = UpsertAddressResp{} }
func (m *UpsertAddressResp) String() string            { return proto1.CompactTextString(m) }
func (*UpsertAddressResp) ProtoMessage()               {}
func (*UpsertAddressResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{48} }

func (m *UpsertAddressResp) GetAddress() *Address {
	if m != nil {
		return m.Address
	}
	return nil
}

type RetireAccountReq struct {
	AccountID string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"accountID"`
}

func (m *RetireAccountReq) Reset()                    { *m = RetireAccountReq{} }
func (m *RetireAccountReq) String() string            { return proto1.CompactTextString(m) }
func (*RetireAccountReq) ProtoMessage()               {}
func (*RetireAccountReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{49} }

type UpsertAccountReq struct {
	Account *Account `protobuf:"bytes,1,opt,name=account" json:"account"`
}

func (m *UpsertAccountReq) Reset()                    { *m = UpsertAccountReq{} }
func (m *UpsertAccountReq) String() string            { return proto1.CompactTextString(m) }
func (*UpsertAccountReq) ProtoMessage()               {}
func (*UpsertAccountReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{50} }

func (m *UpsertAccountReq) GetAccount() *Account {
	if m != nil {
		return m.Account
	}
	return nil
}

type UpsertAccountResp struct {
	Account *Account `protobuf:"bytes,1,opt,name=account" json:"account"`
}

func (m *UpsertAccountResp) Reset()                    { *m = UpsertAccountResp{} }
func (m *UpsertAccountResp) String() string            { return proto1.CompactTextString(m) }
func (*UpsertAccountResp) ProtoMessage()               {}
func (*UpsertAccountResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{51} }

func (m *UpsertAccountResp) GetAccount() *Account {
	if m != nil {
		return m.Account
	}
	return nil
}

type RetireAccountResp struct {
	Retired bool `protobuf:"varint,1,opt,name=retired,proto3" json:"retired"`
}

func (m *RetireAccountResp) Reset()                    { *m = RetireAccountResp{} }
func (m *RetireAccountResp) String() string            { return proto1.CompactTextString(m) }
func (*RetireAccountResp) ProtoMessage()               {}
func (*RetireAccountResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{52} }

type ConvertExternallyCreatedAccountsReq struct {
	DexID string `protobuf:"bytes,1,opt,name=dex_id,json=dexId,proto3" json:"dexID"`
	Email string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
}

func (m *ConvertExternallyCreatedAccountsReq) Reset()         { *m = ConvertExternallyCreatedAccountsReq{} }
func (m *ConvertExternallyCreatedAccountsReq) String() string { return proto1.CompactTextString(m) }
func (*ConvertExternallyCreatedAccountsReq) ProtoMessage()    {}
func (*ConvertExternallyCreatedAccountsReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{53}
}

type ConvertExternallyCreatedAccountsResp struct {
	ConvertedAccountIDs []string `protobuf:"bytes,1,rep,name=converted_account_ids,json=convertedAccountIds" json:"convertedAccountIDs"`
}

func (m *ConvertExternallyCreatedAccountsResp) Reset()         { *m = ConvertExternallyCreatedAccountsResp{} }
func (m *ConvertExternallyCreatedAccountsResp) String() string { return proto1.CompactTextString(m) }
func (*ConvertExternallyCreatedAccountsResp) ProtoMessage()    {}
func (*ConvertExternallyCreatedAccountsResp) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{54}
}

type Profile struct {
	ID          string     `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	AccountID   string     `protobuf:"bytes,2,opt,name=account_id,json=accountId,proto3" json:"accountID"`
	CompanyName string     `protobuf:"bytes,3,opt,name=company_name,json=companyName,proto3" json:"companyName"`
	Email       string     `protobuf:"bytes,4,opt,name=email,proto3" json:"email"`
	FirstName   string     `protobuf:"bytes,5,opt,name=first_name,json=firstName,proto3" json:"firstName"`
	LastName    string     `protobuf:"bytes,6,opt,name=last_name,json=lastName,proto3" json:"lastName"`
	Landline    string     `protobuf:"bytes,7,opt,name=landline,proto3" json:"landline"`
	Mobile      string     `protobuf:"bytes,8,opt,name=mobile,proto3" json:"mobile"`
	Addresses   []*Address `protobuf:"bytes,9,rep,name=addresses" json:"addresses"`
}

func (m *Profile) Reset()                    { *m = Profile{} }
func (m *Profile) String() string            { return proto1.CompactTextString(m) }
func (*Profile) ProtoMessage()               {}
func (*Profile) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{55} }

func (m *Profile) GetAddresses() []*Address {
	if m != nil {
		return m.Addresses
	}
	return nil
}

type Address struct {
	ID             string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	AddressLine1   string `protobuf:"bytes,2,opt,name=addressLine1,proto3" json:"addressLine1"`
	AddressLine2   string `protobuf:"bytes,3,opt,name=addressLine2,proto3" json:"addressLine2"`
	AddressLine3   string `protobuf:"bytes,4,opt,name=addressLine3,proto3" json:"addressLine3"`
	City           string `protobuf:"bytes,5,opt,name=city,proto3" json:"city"`
	Province       string `protobuf:"bytes,6,opt,name=province,proto3" json:"province"`
	Country        string `protobuf:"bytes,7,opt,name=country,proto3" json:"country"`
	Postcode       string `protobuf:"bytes,8,opt,name=postcode,proto3" json:"postcode"`
	Landline       string `protobuf:"bytes,9,opt,name=landline,proto3" json:"landline"`
	ProfileID      string `protobuf:"bytes,10,opt,name=profile_id,json=profileId,proto3" json:"profileID"`
	PrimaryAddress bool   `protobuf:"varint,11,opt,name=primary_address,json=primaryAddress,proto3" json:"primaryAddress"`
}

func (m *Address) Reset()                    { *m = Address{} }
func (m *Address) String() string            { return proto1.CompactTextString(m) }
func (*Address) ProtoMessage()               {}
func (*Address) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{56} }

type Account struct {
	ID              string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Profile         *Profile          `protobuf:"bytes,2,opt,name=profile" json:"profile"`
	QuayID          string            `protobuf:"bytes,3,opt,name=quay_id,json=quayId,proto3" json:"quayID"`
	NewsletterEmail bool              `protobuf:"varint,4,opt,name=newsletter_email,json=newsletterEmail,proto3" json:"newsletterEmail"`
	Deleted         bool              `protobuf:"varint,5,opt,name=deleted,proto3" json:"deleted"`
	CreatedAt       *common.Timestamp `protobuf:"bytes,6,opt,name=created_at,json=createdAt" json:"createdAt"`
}

func (m *Account) Reset()                    { *m = Account{} }
func (m *Account) String() string            { return proto1.CompactTextString(m) }
func (*Account) ProtoMessage()               {}
func (*Account) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{57} }

func (m *Account) GetProfile() *Profile {
	if m != nil {
		return m.Profile
	}
	return nil
}

func (m *Account) GetCreatedAt() *common.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

type Subscription struct {
	ID                        string                        `protobuf:"bytes,2,opt,name=id,proto3" json:"id"`
	VersionID                 string                        `protobuf:"bytes,3,opt,name=version_id,json=versionId,proto3" json:"versionID"`
	AccountID                 string                        `protobuf:"bytes,4,opt,name=account_id,json=accountId,proto3" json:"accountID"`
	ProductID                 string                        `protobuf:"bytes,5,opt,name=product_id,json=productId,proto3" json:"productID"`
	ProductRatePlanID         string                        `protobuf:"bytes,6,opt,name=product_rate_plan_id,json=productRatePlanId,proto3" json:"productRatePlanID"`
	Name                      string                        `protobuf:"bytes,7,opt,name=name,proto3" json:"name"`
	State                     SubscriptionState             `protobuf:"varint,8,opt,name=state,proto3,enum=proto.SubscriptionState" json:"state"`
	StateDescription          string                        `protobuf:"bytes,9,opt,name=state_description,json=stateDescription,proto3" json:"stateDescription"`
	StateSeverity             StateSeverity                 `protobuf:"varint,10,opt,name=state_severity,json=stateSeverity,proto3,enum=proto.StateSeverity" json:"stateSeverity"`
	CurrentPeriodStart        *common.Timestamp             `protobuf:"bytes,11,opt,name=current_period_start,json=currentPeriodStart" json:"currentPeriodStart"`
	CurrentPeriodEnd          *common.Timestamp             `protobuf:"bytes,12,opt,name=current_period_end,json=currentPeriodEnd" json:"currentPeriodEnd"`
	InitialPeriodStart        *common.Timestamp             `protobuf:"bytes,13,opt,name=initial_period_start,json=initialPeriodStart" json:"initialPeriodStart"`
	TrialEnd                  *common.Timestamp             `protobuf:"bytes,14,opt,name=trial_end,json=trialEnd" json:"trialEnd"`
	SubscriptionEnd           *common.Timestamp             `protobuf:"bytes,15,opt,name=subscription_end,json=subscriptionEnd" json:"subscriptionEnd"`
	ContractStart             *common.Timestamp             `protobuf:"bytes,16,opt,name=contract_start,json=contractStart" json:"contractStart"`
	SuccessfulPeriods         int32                         `protobuf:"varint,17,opt,name=successful_periods,json=successfulPeriods,proto3" json:"successfulPeriods"`
	TotalPeriods              int32                         `protobuf:"varint,18,opt,name=total_periods,json=totalPeriods,proto3" json:"totalPeriods"`
	CreditEnabled             bool                          `protobuf:"varint,19,opt,name=credit_enabled,json=creditEnabled,proto3" json:"creditEnabled"`
	Product                   *Product                      `protobuf:"bytes,20,opt,name=product" json:"product"`
	RatePlan                  *RatePlan                     `protobuf:"bytes,21,opt,name=rate_plan,json=ratePlan" json:"ratePlan"`
	Aggregating               bool                          `protobuf:"varint,22,opt,name=aggregating,proto3" json:"aggregating"`
	Type                      Subscription_SubscriptionType `protobuf:"varint,23,opt,name=type,proto3,enum=proto.Subscription_SubscriptionType" json:"type"`
	AgreedTOS                 bool                          `protobuf:"varint,24,opt,name=agreed_tos,json=agreedTos,proto3" json:"agreedTOS"`
	PaymentType               Subscription_PaymentType      `protobuf:"varint,25,opt,name=payment_type,json=paymentType,proto3,enum=proto.Subscription_PaymentType" json:"paymentType"`
	BypassPaymentVerification bool                          `protobuf:"varint,26,opt,name=bypass_payment_verification,json=bypassPaymentVerification,proto3" json:"bypassPaymentVerification"`
	ChangelogEmails           bool                          `protobuf:"varint,27,opt,name=changelog_emails,json=changelogEmails,proto3" json:"changelogEmails"`
	PricingComponentValues    []*PricingComponentValue      `protobuf:"bytes,28,rep,name=pricing_component_values,json=pricingComponentValues" json:"pricingComponentValues"`
	FailedPaymentBehaviour    string                        `protobuf:"bytes,29,opt,name=failed_payment_behaviour,json=failedPaymentBehaviour,proto3" json:"failedPaymentBehaviour"`
}

func (m *Subscription) Reset()                    { *m = Subscription{} }
func (m *Subscription) String() string            { return proto1.CompactTextString(m) }
func (*Subscription) ProtoMessage()               {}
func (*Subscription) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{58} }

func (m *Subscription) GetCurrentPeriodStart() *common.Timestamp {
	if m != nil {
		return m.CurrentPeriodStart
	}
	return nil
}

func (m *Subscription) GetCurrentPeriodEnd() *common.Timestamp {
	if m != nil {
		return m.CurrentPeriodEnd
	}
	return nil
}

func (m *Subscription) GetInitialPeriodStart() *common.Timestamp {
	if m != nil {
		return m.InitialPeriodStart
	}
	return nil
}

func (m *Subscription) GetTrialEnd() *common.Timestamp {
	if m != nil {
		return m.TrialEnd
	}
	return nil
}

func (m *Subscription) GetSubscriptionEnd() *common.Timestamp {
	if m != nil {
		return m.SubscriptionEnd
	}
	return nil
}

func (m *Subscription) GetContractStart() *common.Timestamp {
	if m != nil {
		return m.ContractStart
	}
	return nil
}

func (m *Subscription) GetProduct() *Product {
	if m != nil {
		return m.Product
	}
	return nil
}

func (m *Subscription) GetRatePlan() *RatePlan {
	if m != nil {
		return m.RatePlan
	}
	return nil
}

func (m *Subscription) GetPricingComponentValues() []*PricingComponentValue {
	if m != nil {
		return m.PricingComponentValues
	}
	return nil
}

type PricingComponentValue struct {
	PricingComponentID   string                                      `protobuf:"bytes,2,opt,name=pricing_component_id,json=pricingComponentId,proto3" json:"pricingComponentID"`
	PricingComponentName string                                      `protobuf:"bytes,3,opt,name=pricing_component_name,json=pricingComponentName,proto3" json:"pricingComponentName"`
	Value                int64                                       `protobuf:"varint,4,opt,name=value,proto3" json:"value"`
	PricingComponentInfo *PricingComponentValue_PricingComponentInfo `protobuf:"bytes,5,opt,name=pricing_component_info,json=pricingComponentInfo" json:"pricingComponentInfo"`
}

func (m *PricingComponentValue) Reset()                    { *m = PricingComponentValue{} }
func (m *PricingComponentValue) String() string            { return proto1.CompactTextString(m) }
func (*PricingComponentValue) ProtoMessage()               {}
func (*PricingComponentValue) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{59} }

func (m *PricingComponentValue) GetPricingComponentInfo() *PricingComponentValue_PricingComponentInfo {
	if m != nil {
		return m.PricingComponentInfo
	}
	return nil
}

type PricingComponentValue_PricingComponentInfo struct {
	PublicName          string         `protobuf:"bytes,1,opt,name=public_name,json=publicName,proto3" json:"publicName"`
	Description         string         `protobuf:"bytes,2,opt,name=description,proto3" json:"description"`
	InferredFromDefault bool           `protobuf:"varint,3,opt,name=inferred_from_default,json=inferredFromDefault,proto3" json:"inferredFromDefault"`
	UnitOfMeasure       *UnitOfMeasure `protobuf:"bytes,4,opt,name=unit_of_measure,json=unitOfMeasure" json:"unitOfMeasure"`
}

func (m *PricingComponentValue_PricingComponentInfo) Reset() {
	*m = PricingComponentValue_PricingComponentInfo{}
}
func (m *PricingComponentValue_PricingComponentInfo) String() string {
	return proto1.CompactTextString(m)
}
func (*PricingComponentValue_PricingComponentInfo) ProtoMessage() {}
func (*PricingComponentValue_PricingComponentInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{59, 0}
}

func (m *PricingComponentValue_PricingComponentInfo) GetUnitOfMeasure() *UnitOfMeasure {
	if m != nil {
		return m.UnitOfMeasure
	}
	return nil
}

type RoleValue struct {
	Value Role `protobuf:"varint,1,opt,name=value,proto3,enum=proto.Role" json:"value,omitempty"`
}

func (m *RoleValue) Reset()                    { *m = RoleValue{} }
func (m *RoleValue) String() string            { return proto1.CompactTextString(m) }
func (*RoleValue) ProtoMessage()               {}
func (*RoleValue) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{60} }

type User struct {
	DexID        string              `protobuf:"bytes,1,opt,name=dex_id,json=dexId,proto3" json:"dexID"`
	Email        string              `protobuf:"bytes,2,opt,name=email,proto3" json:"email"`
	AccountRoles []*User_AccountRole `protobuf:"bytes,3,rep,name=account_roles,json=accountRoles" json:"accountRoles"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto1.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{61} }

func (m *User) GetAccountRoles() []*User_AccountRole {
	if m != nil {
		return m.AccountRoles
	}
	return nil
}

type User_AccountRole struct {
	AccountID string     `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"accountID"`
	Role      *RoleValue `protobuf:"bytes,2,opt,name=role" json:"role,omitempty"`
}

func (m *User_AccountRole) Reset()                    { *m = User_AccountRole{} }
func (m *User_AccountRole) String() string            { return proto1.CompactTextString(m) }
func (*User_AccountRole) ProtoMessage()               {}
func (*User_AccountRole) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{61, 0} }

func (m *User_AccountRole) GetRole() *RoleValue {
	if m != nil {
		return m.Role
	}
	return nil
}

type UserListUser struct {
	DexID string `protobuf:"bytes,1,opt,name=dex_id,json=dexId,proto3" json:"dexID"`
	Email string `protobuf:"bytes,2,opt,name=email,proto3" json:"email"`
	Role  Role   `protobuf:"varint,3,opt,name=role,proto3,enum=proto.Role" json:"role"`
}

func (m *UserListUser) Reset()                    { *m = UserListUser{} }
func (m *UserListUser) String() string            { return proto1.CompactTextString(m) }
func (*UserListUser) ProtoMessage()               {}
func (*UserListUser) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{62} }

type PricingComponentQuantity struct {
	PricingComponent string `protobuf:"bytes,1,opt,name=pricing_component,json=pricingComponent,proto3" json:"pricingComponent"`
	Quantity         int64  `protobuf:"varint,2,opt,name=quantity,proto3" json:"quantity"`
}

func (m *PricingComponentQuantity) Reset()                    { *m = PricingComponentQuantity{} }
func (m *PricingComponentQuantity) String() string            { return proto1.CompactTextString(m) }
func (*PricingComponentQuantity) ProtoMessage()               {}
func (*PricingComponentQuantity) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{63} }

type CreateSubscriptionReq struct {
	AccountID                  string                            `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"accountID"`
	ProductID                  string                            `protobuf:"bytes,2,opt,name=product_id,json=productId,proto3" json:"productID"`
	ProductRatePlanID          string                            `protobuf:"bytes,3,opt,name=product_rate_plan_id,json=productRatePlanId,proto3" json:"productRatePlanID"`
	AgreedTOS                  bool                              `protobuf:"varint,4,opt,name=agreed_tos,json=agreedTos,proto3" json:"agreedTOS"`
	ChangelogEmails            bool                              `protobuf:"varint,5,opt,name=changelog_emails,json=changelogEmails,proto3" json:"changelogEmails"`
	PaymentType                CreateSubscriptionReq_PaymentType `protobuf:"varint,6,opt,name=payment_type,json=paymentType,proto3,enum=proto.CreateSubscriptionReq_PaymentType" json:"paymentType"`
	State                      SubscriptionState                 `protobuf:"varint,7,opt,name=state,proto3,enum=proto.SubscriptionState" json:"state"`
	PricingComponentQuantities []*PricingComponentQuantity       `protobuf:"bytes,8,rep,name=pricing_component_quantities,json=pricingComponentQuantities" json:"pricingComponentQuantities"`
}

func (m *CreateSubscriptionReq) Reset()                    { *m = CreateSubscriptionReq{} }
func (m *CreateSubscriptionReq) String() string            { return proto1.CompactTextString(m) }
func (*CreateSubscriptionReq) ProtoMessage()               {}
func (*CreateSubscriptionReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{64} }

func (m *CreateSubscriptionReq) GetPricingComponentQuantities() []*PricingComponentQuantity {
	if m != nil {
		return m.PricingComponentQuantities
	}
	return nil
}

type CreateSubscriptionResp struct {
	Subscription *Subscription `protobuf:"bytes,1,opt,name=subscription" json:"subscription,omitempty"`
}

func (m *CreateSubscriptionResp) Reset()                    { *m = CreateSubscriptionResp{} }
func (m *CreateSubscriptionResp) String() string            { return proto1.CompactTextString(m) }
func (*CreateSubscriptionResp) ProtoMessage()               {}
func (*CreateSubscriptionResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{65} }

func (m *CreateSubscriptionResp) GetSubscription() *Subscription {
	if m != nil {
		return m.Subscription
	}
	return nil
}

type CancelSubscriptionReq struct {
	SubscriptionID string `protobuf:"bytes,1,opt,name=subscription_id,json=subscriptionId,proto3" json:"subscriptionID"`
	AccountID      string `protobuf:"bytes,2,opt,name=account_id,json=accountId,proto3" json:"accountID"`
	Reason         string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason"`
}

func (m *CancelSubscriptionReq) Reset()                    { *m = CancelSubscriptionReq{} }
func (m *CancelSubscriptionReq) String() string            { return proto1.CompactTextString(m) }
func (*CancelSubscriptionReq) ProtoMessage()               {}
func (*CancelSubscriptionReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{66} }

type CancelSubscriptionResp struct {
}

func (m *CancelSubscriptionResp) Reset()                    { *m = CancelSubscriptionResp{} }
func (m *CancelSubscriptionResp) String() string            { return proto1.CompactTextString(m) }
func (*CancelSubscriptionResp) ProtoMessage()               {}
func (*CancelSubscriptionResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{67} }

type UncancelSubscriptionReq struct {
	SubscriptionID string `protobuf:"bytes,1,opt,name=subscription_id,json=subscriptionId,proto3" json:"subscriptionID"`
	AccountID      string `protobuf:"bytes,2,opt,name=account_id,json=accountId,proto3" json:"accountID"`
}

func (m *UncancelSubscriptionReq) Reset()                    { *m = UncancelSubscriptionReq{} }
func (m *UncancelSubscriptionReq) String() string            { return proto1.CompactTextString(m) }
func (*UncancelSubscriptionReq) ProtoMessage()               {}
func (*UncancelSubscriptionReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{68} }

type UncancelSubscriptionResp struct {
}

func (m *UncancelSubscriptionResp) Reset()                    { *m = UncancelSubscriptionResp{} }
func (m *UncancelSubscriptionResp) String() string            { return proto1.CompactTextString(m) }
func (*UncancelSubscriptionResp) ProtoMessage()               {}
func (*UncancelSubscriptionResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{69} }

type ListSubscriptionsReq struct {
	AccountID      string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"accountID"`
	IncludeRetired bool   `protobuf:"varint,2,opt,name=include_retired,json=includeRetired,proto3" json:"includeRetired"`
}

func (m *ListSubscriptionsReq) Reset()                    { *m = ListSubscriptionsReq{} }
func (m *ListSubscriptionsReq) String() string            { return proto1.CompactTextString(m) }
func (*ListSubscriptionsReq) ProtoMessage()               {}
func (*ListSubscriptionsReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{70} }

type ListSubscriptionsResp struct {
	Parent   *Subscription   `protobuf:"bytes,1,opt,name=parent" json:"parent"`
	Children []*Subscription `protobuf:"bytes,2,rep,name=children" json:"children"`
}

func (m *ListSubscriptionsResp) Reset()                    { *m = ListSubscriptionsResp{} }
func (m *ListSubscriptionsResp) String() string            { return proto1.CompactTextString(m) }
func (*ListSubscriptionsResp) ProtoMessage()               {}
func (*ListSubscriptionsResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{71} }

func (m *ListSubscriptionsResp) GetParent() *Subscription {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *ListSubscriptionsResp) GetChildren() []*Subscription {
	if m != nil {
		return m.Children
	}
	return nil
}

type SetQuayCredentialsReq struct {
	AccountID string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"accountID"`
	QuayID    string `protobuf:"bytes,2,opt,name=quay_id,json=quayId,proto3" json:"quayID"`
	QuayToken string `protobuf:"bytes,3,opt,name=quay_token,json=quayToken,proto3" json:"quay_token,omitempty"`
}

func (m *SetQuayCredentialsReq) Reset()                    { *m = SetQuayCredentialsReq{} }
func (m *SetQuayCredentialsReq) String() string            { return proto1.CompactTextString(m) }
func (*SetQuayCredentialsReq) ProtoMessage()               {}
func (*SetQuayCredentialsReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{72} }

type SetQuayCredentialsResp struct {
}

func (m *SetQuayCredentialsResp) Reset()                    { *m = SetQuayCredentialsResp{} }
func (m *SetQuayCredentialsResp) String() string            { return proto1.CompactTextString(m) }
func (*SetQuayCredentialsResp) ProtoMessage()               {}
func (*SetQuayCredentialsResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{73} }

type GetQuayCredentialsReq struct {
	AccountID string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"accountID"`
}

func (m *GetQuayCredentialsReq) Reset()                    { *m = GetQuayCredentialsReq{} }
func (m *GetQuayCredentialsReq) String() string            { return proto1.CompactTextString(m) }
func (*GetQuayCredentialsReq) ProtoMessage()               {}
func (*GetQuayCredentialsReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{74} }

type GetQuayCredentialsResp struct {
	QuayID    string `protobuf:"bytes,1,opt,name=quay_id,json=quayId,proto3" json:"quayID"`
	QuayToken string `protobuf:"bytes,2,opt,name=quay_token,json=quayToken,proto3" json:"quay_token,omitempty"`
}

func (m *GetQuayCredentialsResp) Reset()                    { *m = GetQuayCredentialsResp{} }
func (m *GetQuayCredentialsResp) String() string            { return proto1.CompactTextString(m) }
func (*GetQuayCredentialsResp) ProtoMessage()               {}
func (*GetQuayCredentialsResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{75} }

type GetAssetsReq struct {
	AccountID string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"accountID"`
}

func (m *GetAssetsReq) Reset()                    { *m = GetAssetsReq{} }
func (m *GetAssetsReq) String() string            { return proto1.CompactTextString(m) }
func (*GetAssetsReq) ProtoMessage()               {}
func (*GetAssetsReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{76} }

type GetAssetsResp struct {
	Assets map[string]*Asset `protobuf:"bytes,1,rep,name=assets" json:"assets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *GetAssetsResp) Reset()                    { *m = GetAssetsResp{} }
func (m *GetAssetsResp) String() string            { return proto1.CompactTextString(m) }
func (*GetAssetsResp) ProtoMessage()               {}
func (*GetAssetsResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{77} }

func (m *GetAssetsResp) GetAssets() map[string]*Asset {
	if m != nil {
		return m.Assets
	}
	return nil
}

type Asset struct {
	Label   string                   `protobuf:"bytes,1,opt,name=label,proto3" json:"label,omitempty"`
	Formats map[string]*OutputFormat `protobuf:"bytes,2,rep,name=formats" json:"formats,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Asset) Reset()                    { *m = Asset{} }
func (m *Asset) String() string            { return proto1.CompactTextString(m) }
func (*Asset) ProtoMessage()               {}
func (*Asset) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{78} }

func (m *Asset) GetFormats() map[string]*OutputFormat {
	if m != nil {
		return m.Formats
	}
	return nil
}

type OutputFormat struct {
	Label    string `protobuf:"bytes,1,opt,name=label,proto3" json:"label,omitempty"`
	Value    string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Type     string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	Filename string `protobuf:"bytes,4,opt,name=filename,proto3" json:"filename,omitempty"`
}

func (m *OutputFormat) Reset()                    { *m = OutputFormat{} }
func (m *OutputFormat) String() string            { return proto1.CompactTextString(m) }
func (*OutputFormat) ProtoMessage()               {}
func (*OutputFormat) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{79} }

type CreateLicenseReq struct {
	AccountID string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"accountID"`
}

func (m *CreateLicenseReq) Reset()                    { *m = CreateLicenseReq{} }
func (m *CreateLicenseReq) String() string            { return proto1.CompactTextString(m) }
func (*CreateLicenseReq) ProtoMessage()               {}
func (*CreateLicenseReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{80} }

type CreateLicenseResp struct {
}

func (m *CreateLicenseResp) Reset()                    { *m = CreateLicenseResp{} }
func (m *CreateLicenseResp) String() string            { return proto1.CompactTextString(m) }
func (*CreateLicenseResp) ProtoMessage()               {}
func (*CreateLicenseResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{81} }

type GetAccountStatusReq struct {
	AccountID string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"accountID"`
}

func (m *GetAccountStatusReq) Reset()                    { *m = GetAccountStatusReq{} }
func (m *GetAccountStatusReq) String() string            { return proto1.CompactTextString(m) }
func (*GetAccountStatusReq) ProtoMessage()               {}
func (*GetAccountStatusReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{82} }

type GetAccountStatusResp struct {
	Balance             float64                            `protobuf:"fixed64,1,opt,name=balance,proto3" json:"balance"`
	Status              GetAccountStatusResp_AccountStatus `protobuf:"varint,2,opt,name=status,proto3,enum=proto.GetAccountStatusResp_AccountStatus" json:"status"`
	StatusDescription   string                             `protobuf:"bytes,3,opt,name=status_description,json=statusDescription,proto3" json:"statusDescription"`
	NextInvoiceDate     *common.Timestamp                  `protobuf:"bytes,4,opt,name=next_invoice_date,json=nextInvoiceDate" json:"nextInvoiceDate"`
	PurchasedProductIDs []string                           `protobuf:"bytes,5,rep,name=purchased_product_ids,json=purchasedProductIds" json:"purchasedProductIDs"`
}

func (m *GetAccountStatusResp) Reset()                    { *m = GetAccountStatusResp{} }
func (m *GetAccountStatusResp) String() string            { return proto1.CompactTextString(m) }
func (*GetAccountStatusResp) ProtoMessage()               {}
func (*GetAccountStatusResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{83} }

func (m *GetAccountStatusResp) GetNextInvoiceDate() *common.Timestamp {
	if m != nil {
		return m.NextInvoiceDate
	}
	return nil
}

type TerminateAccountReq struct {
	AccountID string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"accountID"`
}

func (m *TerminateAccountReq) Reset()                    { *m = TerminateAccountReq{} }
func (m *TerminateAccountReq) String() string            { return proto1.CompactTextString(m) }
func (*TerminateAccountReq) ProtoMessage()               {}
func (*TerminateAccountReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{84} }

type TerminateAccountResp struct {
}

func (m *TerminateAccountResp) Reset()                    { *m = TerminateAccountResp{} }
func (m *TerminateAccountResp) String() string            { return proto1.CompactTextString(m) }
func (*TerminateAccountResp) ProtoMessage()               {}
func (*TerminateAccountResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{85} }

type AdvanceAccountReq struct {
	AccountID string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"accountID"`
	Periods   int32  `protobuf:"varint,2,opt,name=periods,proto3" json:"periods"`
}

func (m *AdvanceAccountReq) Reset()                    { *m = AdvanceAccountReq{} }
func (m *AdvanceAccountReq) String() string            { return proto1.CompactTextString(m) }
func (*AdvanceAccountReq) ProtoMessage()               {}
func (*AdvanceAccountReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{86} }

type AdvanceAccountResp struct {
}

func (m *AdvanceAccountResp) Reset()                    { *m = AdvanceAccountResp{} }
func (m *AdvanceAccountResp) String() string            { return proto1.CompactTextString(m) }
func (*AdvanceAccountResp) ProtoMessage()               {}
func (*AdvanceAccountResp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{87} }

func init() {
	proto1.RegisterType((*CreditCard)(nil), "proto.CreditCard")
	proto1.RegisterType((*CreateCreditCardReq)(nil), "proto.CreateCreditCardReq")
	proto1.RegisterType((*CreateCreditCardResp)(nil), "proto.CreateCreditCardResp")
	proto1.RegisterType((*GetCreditCardReq)(nil), "proto.GetCreditCardReq")
	proto1.RegisterType((*GetCreditCardResp)(nil), "proto.GetCreditCardResp")
	proto1.RegisterType((*ListProductsReq)(nil), "proto.ListProductsReq")
	proto1.RegisterType((*ListProductsResp)(nil), "proto.ListProductsResp")
	proto1.RegisterType((*Product)(nil), "proto.Product")
	proto1.RegisterType((*RatePlan)(nil), "proto.RatePlan")
	proto1.RegisterType((*PricingComponent)(nil), "proto.PricingComponent")
	proto1.RegisterType((*PricingComponentTiers)(nil), "proto.PricingComponentTiers")
	proto1.RegisterType((*UnitOfMeasure)(nil), "proto.UnitOfMeasure")
	proto1.RegisterType((*ListInvoicesReq)(nil), "proto.ListInvoicesReq")
	proto1.RegisterType((*ListInvoicesResp)(nil), "proto.ListInvoicesResp")
	proto1.RegisterType((*GetInvoiceReq)(nil), "proto.GetInvoiceReq")
	proto1.RegisterType((*GetInvoiceResp)(nil), "proto.GetInvoiceResp")
	proto1.RegisterType((*Invoice)(nil), "proto.Invoice")
	proto1.RegisterType((*GetInvoiceAsPDFReq)(nil), "proto.GetInvoiceAsPDFReq")
	proto1.RegisterType((*GetInvoiceAsPDFResp)(nil), "proto.GetInvoiceAsPDFResp")
	proto1.RegisterType((*CreateUserReq)(nil), "proto.CreateUserReq")
	proto1.RegisterType((*CreateUserResp)(nil), "proto.CreateUserResp")
	proto1.RegisterType((*GetUserReq)(nil), "proto.GetUserReq")
	proto1.RegisterType((*GetUserResp)(nil), "proto.GetUserResp")
	proto1.RegisterType((*ListAccountUsersReq)(nil), "proto.ListAccountUsersReq")
	proto1.RegisterType((*ListAccountUsersResp)(nil), "proto.ListAccountUsersResp")
	proto1.RegisterType((*InviteUserReq)(nil), "proto.InviteUserReq")
	proto1.RegisterType((*InviteUserResp)(nil), "proto.InviteUserResp")
	proto1.RegisterType((*AcceptUserInvitationReq)(nil), "proto.AcceptUserInvitationReq")
	proto1.RegisterType((*AcceptUserInvitationResp)(nil), "proto.AcceptUserInvitationResp")
	proto1.RegisterType((*AcceptAllUserInvitationsReq)(nil), "proto.AcceptAllUserInvitationsReq")
	proto1.RegisterType((*AcceptAllUserInvitationsResp)(nil), "proto.AcceptAllUserInvitationsResp")
	proto1.RegisterType((*RevokeUserAccountAccessReq)(nil), "proto.RevokeUserAccountAccessReq")
	proto1.RegisterType((*ChangeUserRoleReq)(nil), "proto.ChangeUserRoleReq")
	proto1.RegisterType((*ChangeUserRoleResp)(nil), "proto.ChangeUserRoleResp")
	proto1.RegisterType((*RevokeUserAccountAccessResp)(nil), "proto.RevokeUserAccountAccessResp")
	proto1.RegisterType((*GetAccountReq)(nil), "proto.GetAccountReq")
	proto1.RegisterType((*GetAccountResp)(nil), "proto.GetAccountResp")
	proto1.RegisterType((*ListAccountsReq)(nil), "proto.ListAccountsReq")
	proto1.RegisterType((*ListAccountsResp)(nil), "proto.ListAccountsResp")
	proto1.RegisterType((*CreateAccountReq)(nil), "proto.CreateAccountReq")
	proto1.RegisterType((*CreateAccountResp)(nil), "proto.CreateAccountResp")
	proto1.RegisterType((*UpdateProfileReq)(nil), "proto.UpdateProfileReq")
	proto1.RegisterType((*UpdateProfileResp)(nil), "proto.UpdateProfileResp")
	proto1.RegisterType((*CreateAddressReq)(nil), "proto.CreateAddressReq")
	proto1.RegisterType((*CreateAddressResp)(nil), "proto.CreateAddressResp")
	proto1.RegisterType((*UpdateAddressReq)(nil), "proto.UpdateAddressReq")
	proto1.RegisterType((*UpdateAddressResp)(nil), "proto.UpdateAddressResp")
	proto1.RegisterType((*UpsertAddressReq)(nil), "proto.UpsertAddressReq")
	proto1.RegisterType((*UpsertAddressResp)(nil), "proto.UpsertAddressResp")
	proto1.RegisterType((*RetireAccountReq)(nil), "proto.RetireAccountReq")
	proto1.RegisterType((*UpsertAccountReq)(nil), "proto.UpsertAccountReq")
	proto1.RegisterType((*UpsertAccountResp)(nil), "proto.UpsertAccountResp")
	proto1.RegisterType((*RetireAccountResp)(nil), "proto.RetireAccountResp")
	proto1.RegisterType((*ConvertExternallyCreatedAccountsReq)(nil), "proto.ConvertExternallyCreatedAccountsReq")
	proto1.RegisterType((*ConvertExternallyCreatedAccountsResp)(nil), "proto.ConvertExternallyCreatedAccountsResp")
	proto1.RegisterType((*Profile)(nil), "proto.Profile")
	proto1.RegisterType((*Address)(nil), "proto.Address")
	proto1.RegisterType((*Account)(nil), "proto.Account")
	proto1.RegisterType((*Subscription)(nil), "proto.Subscription")
	proto1.RegisterType((*PricingComponentValue)(nil), "proto.PricingComponentValue")
	proto1.RegisterType((*PricingComponentValue_PricingComponentInfo)(nil), "proto.PricingComponentValue.PricingComponentInfo")
	proto1.RegisterType((*RoleValue)(nil), "proto.RoleValue")
	proto1.RegisterType((*User)(nil), "proto.User")
	proto1.RegisterType((*User_AccountRole)(nil), "proto.User.AccountRole")
	proto1.RegisterType((*UserListUser)(nil), "proto.UserListUser")
	proto1.RegisterType((*PricingComponentQuantity)(nil), "proto.PricingComponentQuantity")
	proto1.RegisterType((*CreateSubscriptionReq)(nil), "proto.CreateSubscriptionReq")
	proto1.RegisterType((*CreateSubscriptionResp)(nil), "proto.CreateSubscriptionResp")
	proto1.RegisterType((*CancelSubscriptionReq)(nil), "proto.CancelSubscriptionReq")
	proto1.RegisterType((*CancelSubscriptionResp)(nil), "proto.CancelSubscriptionResp")
	proto1.RegisterType((*UncancelSubscriptionReq)(nil), "proto.UncancelSubscriptionReq")
	proto1.RegisterType((*UncancelSubscriptionResp)(nil), "proto.UncancelSubscriptionResp")
	proto1.RegisterType((*ListSubscriptionsReq)(nil), "proto.ListSubscriptionsReq")
	proto1.RegisterType((*ListSubscriptionsResp)(nil), "proto.ListSubscriptionsResp")
	proto1.RegisterType((*SetQuayCredentialsReq)(nil), "proto.SetQuayCredentialsReq")
	proto1.RegisterType((*SetQuayCredentialsResp)(nil), "proto.SetQuayCredentialsResp")
	proto1.RegisterType((*GetQuayCredentialsReq)(nil), "proto.GetQuayCredentialsReq")
	proto1.RegisterType((*GetQuayCredentialsResp)(nil), "proto.GetQuayCredentialsResp")
	proto1.RegisterType((*GetAssetsReq)(nil), "proto.GetAssetsReq")
	proto1.RegisterType((*GetAssetsResp)(nil), "proto.GetAssetsResp")
	proto1.RegisterType((*Asset)(nil), "proto.Asset")
	proto1.RegisterType((*OutputFormat)(nil), "proto.OutputFormat")
	proto1.RegisterType((*CreateLicenseReq)(nil), "proto.CreateLicenseReq")
	proto1.RegisterType((*CreateLicenseResp)(nil), "proto.CreateLicenseResp")
	proto1.RegisterType((*GetAccountStatusReq)(nil), "proto.GetAccountStatusReq")
	proto1.RegisterType((*GetAccountStatusResp)(nil), "proto.GetAccountStatusResp")
	proto1.RegisterType((*TerminateAccountReq)(nil), "proto.TerminateAccountReq")
	proto1.RegisterType((*TerminateAccountResp)(nil), "proto.TerminateAccountResp")
	proto1.RegisterType((*AdvanceAccountReq)(nil), "proto.AdvanceAccountReq")
	proto1.RegisterType((*AdvanceAccountResp)(nil), "proto.AdvanceAccountResp")
	proto1.RegisterEnum("proto.StateSeverity", StateSeverity_name, StateSeverity_value)
	proto1.RegisterEnum("proto.Role", Role_name, Role_value)
	proto1.RegisterEnum("proto.AssetType", AssetType_name, AssetType_value)
	proto1.RegisterEnum("proto.SubscriptionState", SubscriptionState_name, SubscriptionState_value)
	proto1.RegisterEnum("proto.CreditCard_CreditCardState", CreditCard_CreditCardState_name, CreditCard_CreditCardState_value)
	proto1.RegisterEnum("proto.Subscription_PaymentType", Subscription_PaymentType_name, Subscription_PaymentType_value)
	proto1.RegisterEnum("proto.Subscription_SubscriptionType", Subscription_SubscriptionType_name, Subscription_SubscriptionType_value)
	proto1.RegisterEnum("proto.CreateSubscriptionReq_PaymentType", CreateSubscriptionReq_PaymentType_name, CreateSubscriptionReq_PaymentType_value)
	proto1.RegisterEnum("proto.GetAccountStatusResp_AccountStatus", GetAccountStatusResp_AccountStatus_name, GetAccountStatusResp_AccountStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for AccountService service

type AccountServiceClient interface {
	// USERS
	CreateUser(ctx context.Context, in *CreateUserReq, opts ...grpc.CallOption) (*CreateUserResp, error)
	GetUser(ctx context.Context, in *GetUserReq, opts ...grpc.CallOption) (*GetUserResp, error)
	// Invites a user to view/manage an account.
	InviteUser(ctx context.Context, in *InviteUserReq, opts ...grpc.CallOption) (*InviteUserResp, error)
	// User is moved from invited state to regular user with access.
	AcceptUserInvitation(ctx context.Context, in *AcceptUserInvitationReq, opts ...grpc.CallOption) (*AcceptUserInvitationResp, error)
	// Accepts ALL oustanding account invitations for the requesting user.
	AcceptAllUserInvitations(ctx context.Context, in *AcceptAllUserInvitationsReq, opts ...grpc.CallOption) (*AcceptAllUserInvitationsResp, error)
	// User access is removed from an account.
	RevokeUserAccountAccess(ctx context.Context, in *RevokeUserAccountAccessReq, opts ...grpc.CallOption) (*RevokeUserAccountAccessResp, error)
	// User role is changed on an account.
	ChangeUserRole(ctx context.Context, in *ChangeUserRoleReq, opts ...grpc.CallOption) (*ChangeUserRoleResp, error)
	// List all users for an account.
	ListAccountUsers(ctx context.Context, in *ListAccountUsersReq, opts ...grpc.CallOption) (*ListAccountUsersResp, error)
	// ACCOUNTS
	GetAccount(ctx context.Context, in *GetAccountReq, opts ...grpc.CallOption) (*GetAccountResp, error)
	ListAccounts(ctx context.Context, in *ListAccountsReq, opts ...grpc.CallOption) (*ListAccountsResp, error)
	CreateAccount(ctx context.Context, in *CreateAccountReq, opts ...grpc.CallOption) (*CreateAccountResp, error)
	RetireAccount(ctx context.Context, in *RetireAccountReq, opts ...grpc.CallOption) (*RetireAccountResp, error)
	UpsertAccount(ctx context.Context, in *UpsertAccountReq, opts ...grpc.CallOption) (*UpsertAccountResp, error)
	GetAccountStatus(ctx context.Context, in *GetAccountStatusReq, opts ...grpc.CallOption) (*GetAccountStatusResp, error)
	TerminateAccount(ctx context.Context, in *TerminateAccountReq, opts ...grpc.CallOption) (*TerminateAccountResp, error)
	AdvanceAccount(ctx context.Context, in *AdvanceAccountReq, opts ...grpc.CallOption) (*AdvanceAccountResp, error)
	// ACCOUNT PROFILES
	UpdateProfile(ctx context.Context, in *UpdateProfileReq, opts ...grpc.CallOption) (*UpdateProfileResp, error)
	CreateAddress(ctx context.Context, in *CreateAddressReq, opts ...grpc.CallOption) (*CreateAddressResp, error)
	UpdateAddress(ctx context.Context, in *UpdateAddressReq, opts ...grpc.CallOption) (*UpdateAddressResp, error)
	UpsertAddress(ctx context.Context, in *UpsertAddressReq, opts ...grpc.CallOption) (*UpsertAddressResp, error)
	// CREDIT CARD INFO
	CreateCreditCard(ctx context.Context, in *CreateCreditCardReq, opts ...grpc.CallOption) (*CreateCreditCardResp, error)
	GetCreditCard(ctx context.Context, in *GetCreditCardReq, opts ...grpc.CallOption) (*GetCreditCardResp, error)
	// ACCOUNT SUBSCRIPTIONS
	ListSubscriptions(ctx context.Context, in *ListSubscriptionsReq, opts ...grpc.CallOption) (*ListSubscriptionsResp, error)
	CreateSubscription(ctx context.Context, in *CreateSubscriptionReq, opts ...grpc.CallOption) (*CreateSubscriptionResp, error)
	CancelSubscription(ctx context.Context, in *CancelSubscriptionReq, opts ...grpc.CallOption) (*CancelSubscriptionResp, error)
	UncancelSubscription(ctx context.Context, in *UncancelSubscriptionReq, opts ...grpc.CallOption) (*UncancelSubscriptionResp, error)
	GetInvoice(ctx context.Context, in *GetInvoiceReq, opts ...grpc.CallOption) (*GetInvoiceResp, error)
	ListInvoices(ctx context.Context, in *ListInvoicesReq, opts ...grpc.CallOption) (*ListInvoicesResp, error)
	GetInvoiceAsPDF(ctx context.Context, in *GetInvoiceAsPDFReq, opts ...grpc.CallOption) (*GetInvoiceAsPDFResp, error)
	// PRODUCTS
	ListProducts(ctx context.Context, in *ListProductsReq, opts ...grpc.CallOption) (*ListProductsResp, error)
	// INERNAL MGMT
	GetQuayCredentials(ctx context.Context, in *GetQuayCredentialsReq, opts ...grpc.CallOption) (*GetQuayCredentialsResp, error)
	SetQuayCredentials(ctx context.Context, in *SetQuayCredentialsReq, opts ...grpc.CallOption) (*SetQuayCredentialsResp, error)
	ConvertExternallyCreatedAccounts(ctx context.Context, in *ConvertExternallyCreatedAccountsReq, opts ...grpc.CallOption) (*ConvertExternallyCreatedAccountsResp, error)
	CreateLicense(ctx context.Context, in *CreateLicenseReq, opts ...grpc.CallOption) (*CreateLicenseResp, error)
	GetAssets(ctx context.Context, in *GetAssetsReq, opts ...grpc.CallOption) (*GetAssetsResp, error)
}

type accountServiceClient struct {
	cc *grpc.ClientConn
}

func NewAccountServiceClient(cc *grpc.ClientConn) AccountServiceClient {
	return &accountServiceClient{cc}
}

func (c *accountServiceClient) CreateUser(ctx context.Context, in *CreateUserReq, opts ...grpc.CallOption) (*CreateUserResp, error) {
	out := new(CreateUserResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/CreateUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) GetUser(ctx context.Context, in *GetUserReq, opts ...grpc.CallOption) (*GetUserResp, error) {
	out := new(GetUserResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/GetUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) InviteUser(ctx context.Context, in *InviteUserReq, opts ...grpc.CallOption) (*InviteUserResp, error) {
	out := new(InviteUserResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/InviteUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) AcceptUserInvitation(ctx context.Context, in *AcceptUserInvitationReq, opts ...grpc.CallOption) (*AcceptUserInvitationResp, error) {
	out := new(AcceptUserInvitationResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/AcceptUserInvitation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) AcceptAllUserInvitations(ctx context.Context, in *AcceptAllUserInvitationsReq, opts ...grpc.CallOption) (*AcceptAllUserInvitationsResp, error) {
	out := new(AcceptAllUserInvitationsResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/AcceptAllUserInvitations", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) RevokeUserAccountAccess(ctx context.Context, in *RevokeUserAccountAccessReq, opts ...grpc.CallOption) (*RevokeUserAccountAccessResp, error) {
	out := new(RevokeUserAccountAccessResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/RevokeUserAccountAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) ChangeUserRole(ctx context.Context, in *ChangeUserRoleReq, opts ...grpc.CallOption) (*ChangeUserRoleResp, error) {
	out := new(ChangeUserRoleResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/ChangeUserRole", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) ListAccountUsers(ctx context.Context, in *ListAccountUsersReq, opts ...grpc.CallOption) (*ListAccountUsersResp, error) {
	out := new(ListAccountUsersResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/ListAccountUsers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) GetAccount(ctx context.Context, in *GetAccountReq, opts ...grpc.CallOption) (*GetAccountResp, error) {
	out := new(GetAccountResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/GetAccount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) ListAccounts(ctx context.Context, in *ListAccountsReq, opts ...grpc.CallOption) (*ListAccountsResp, error) {
	out := new(ListAccountsResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/ListAccounts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) CreateAccount(ctx context.Context, in *CreateAccountReq, opts ...grpc.CallOption) (*CreateAccountResp, error) {
	out := new(CreateAccountResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/CreateAccount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) RetireAccount(ctx context.Context, in *RetireAccountReq, opts ...grpc.CallOption) (*RetireAccountResp, error) {
	out := new(RetireAccountResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/RetireAccount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) UpsertAccount(ctx context.Context, in *UpsertAccountReq, opts ...grpc.CallOption) (*UpsertAccountResp, error) {
	out := new(UpsertAccountResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/UpsertAccount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) GetAccountStatus(ctx context.Context, in *GetAccountStatusReq, opts ...grpc.CallOption) (*GetAccountStatusResp, error) {
	out := new(GetAccountStatusResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/GetAccountStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) TerminateAccount(ctx context.Context, in *TerminateAccountReq, opts ...grpc.CallOption) (*TerminateAccountResp, error) {
	out := new(TerminateAccountResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/TerminateAccount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) AdvanceAccount(ctx context.Context, in *AdvanceAccountReq, opts ...grpc.CallOption) (*AdvanceAccountResp, error) {
	out := new(AdvanceAccountResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/AdvanceAccount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) UpdateProfile(ctx context.Context, in *UpdateProfileReq, opts ...grpc.CallOption) (*UpdateProfileResp, error) {
	out := new(UpdateProfileResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/UpdateProfile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) CreateAddress(ctx context.Context, in *CreateAddressReq, opts ...grpc.CallOption) (*CreateAddressResp, error) {
	out := new(CreateAddressResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/CreateAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) UpdateAddress(ctx context.Context, in *UpdateAddressReq, opts ...grpc.CallOption) (*UpdateAddressResp, error) {
	out := new(UpdateAddressResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/UpdateAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) UpsertAddress(ctx context.Context, in *UpsertAddressReq, opts ...grpc.CallOption) (*UpsertAddressResp, error) {
	out := new(UpsertAddressResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/UpsertAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) CreateCreditCard(ctx context.Context, in *CreateCreditCardReq, opts ...grpc.CallOption) (*CreateCreditCardResp, error) {
	out := new(CreateCreditCardResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/CreateCreditCard", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) GetCreditCard(ctx context.Context, in *GetCreditCardReq, opts ...grpc.CallOption) (*GetCreditCardResp, error) {
	out := new(GetCreditCardResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/GetCreditCard", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) ListSubscriptions(ctx context.Context, in *ListSubscriptionsReq, opts ...grpc.CallOption) (*ListSubscriptionsResp, error) {
	out := new(ListSubscriptionsResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/ListSubscriptions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) CreateSubscription(ctx context.Context, in *CreateSubscriptionReq, opts ...grpc.CallOption) (*CreateSubscriptionResp, error) {
	out := new(CreateSubscriptionResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/CreateSubscription", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) CancelSubscription(ctx context.Context, in *CancelSubscriptionReq, opts ...grpc.CallOption) (*CancelSubscriptionResp, error) {
	out := new(CancelSubscriptionResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/CancelSubscription", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) UncancelSubscription(ctx context.Context, in *UncancelSubscriptionReq, opts ...grpc.CallOption) (*UncancelSubscriptionResp, error) {
	out := new(UncancelSubscriptionResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/UncancelSubscription", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) GetInvoice(ctx context.Context, in *GetInvoiceReq, opts ...grpc.CallOption) (*GetInvoiceResp, error) {
	out := new(GetInvoiceResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/GetInvoice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) ListInvoices(ctx context.Context, in *ListInvoicesReq, opts ...grpc.CallOption) (*ListInvoicesResp, error) {
	out := new(ListInvoicesResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/ListInvoices", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) GetInvoiceAsPDF(ctx context.Context, in *GetInvoiceAsPDFReq, opts ...grpc.CallOption) (*GetInvoiceAsPDFResp, error) {
	out := new(GetInvoiceAsPDFResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/GetInvoiceAsPDF", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) ListProducts(ctx context.Context, in *ListProductsReq, opts ...grpc.CallOption) (*ListProductsResp, error) {
	out := new(ListProductsResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/ListProducts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) GetQuayCredentials(ctx context.Context, in *GetQuayCredentialsReq, opts ...grpc.CallOption) (*GetQuayCredentialsResp, error) {
	out := new(GetQuayCredentialsResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/GetQuayCredentials", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) SetQuayCredentials(ctx context.Context, in *SetQuayCredentialsReq, opts ...grpc.CallOption) (*SetQuayCredentialsResp, error) {
	out := new(SetQuayCredentialsResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/SetQuayCredentials", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) ConvertExternallyCreatedAccounts(ctx context.Context, in *ConvertExternallyCreatedAccountsReq, opts ...grpc.CallOption) (*ConvertExternallyCreatedAccountsResp, error) {
	out := new(ConvertExternallyCreatedAccountsResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/ConvertExternallyCreatedAccounts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) CreateLicense(ctx context.Context, in *CreateLicenseReq, opts ...grpc.CallOption) (*CreateLicenseResp, error) {
	out := new(CreateLicenseResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/CreateLicense", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServiceClient) GetAssets(ctx context.Context, in *GetAssetsReq, opts ...grpc.CallOption) (*GetAssetsResp, error) {
	out := new(GetAssetsResp)
	err := grpc.Invoke(ctx, "/proto.AccountService/GetAssets", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AccountService service

type AccountServiceServer interface {
	// USERS
	CreateUser(context.Context, *CreateUserReq) (*CreateUserResp, error)
	GetUser(context.Context, *GetUserReq) (*GetUserResp, error)
	// Invites a user to view/manage an account.
	InviteUser(context.Context, *InviteUserReq) (*InviteUserResp, error)
	// User is moved from invited state to regular user with access.
	AcceptUserInvitation(context.Context, *AcceptUserInvitationReq) (*AcceptUserInvitationResp, error)
	// Accepts ALL oustanding account invitations for the requesting user.
	AcceptAllUserInvitations(context.Context, *AcceptAllUserInvitationsReq) (*AcceptAllUserInvitationsResp, error)
	// User access is removed from an account.
	RevokeUserAccountAccess(context.Context, *RevokeUserAccountAccessReq) (*RevokeUserAccountAccessResp, error)
	// User role is changed on an account.
	ChangeUserRole(context.Context, *ChangeUserRoleReq) (*ChangeUserRoleResp, error)
	// List all users for an account.
	ListAccountUsers(context.Context, *ListAccountUsersReq) (*ListAccountUsersResp, error)
	// ACCOUNTS
	GetAccount(context.Context, *GetAccountReq) (*GetAccountResp, error)
	ListAccounts(context.Context, *ListAccountsReq) (*ListAccountsResp, error)
	CreateAccount(context.Context, *CreateAccountReq) (*CreateAccountResp, error)
	RetireAccount(context.Context, *RetireAccountReq) (*RetireAccountResp, error)
	UpsertAccount(context.Context, *UpsertAccountReq) (*UpsertAccountResp, error)
	GetAccountStatus(context.Context, *GetAccountStatusReq) (*GetAccountStatusResp, error)
	TerminateAccount(context.Context, *TerminateAccountReq) (*TerminateAccountResp, error)
	AdvanceAccount(context.Context, *AdvanceAccountReq) (*AdvanceAccountResp, error)
	// ACCOUNT PROFILES
	UpdateProfile(context.Context, *UpdateProfileReq) (*UpdateProfileResp, error)
	CreateAddress(context.Context, *CreateAddressReq) (*CreateAddressResp, error)
	UpdateAddress(context.Context, *UpdateAddressReq) (*UpdateAddressResp, error)
	UpsertAddress(context.Context, *UpsertAddressReq) (*UpsertAddressResp, error)
	// CREDIT CARD INFO
	CreateCreditCard(context.Context, *CreateCreditCardReq) (*CreateCreditCardResp, error)
	GetCreditCard(context.Context, *GetCreditCardReq) (*GetCreditCardResp, error)
	// ACCOUNT SUBSCRIPTIONS
	ListSubscriptions(context.Context, *ListSubscriptionsReq) (*ListSubscriptionsResp, error)
	CreateSubscription(context.Context, *CreateSubscriptionReq) (*CreateSubscriptionResp, error)
	CancelSubscription(context.Context, *CancelSubscriptionReq) (*CancelSubscriptionResp, error)
	UncancelSubscription(context.Context, *UncancelSubscriptionReq) (*UncancelSubscriptionResp, error)
	GetInvoice(context.Context, *GetInvoiceReq) (*GetInvoiceResp, error)
	ListInvoices(context.Context, *ListInvoicesReq) (*ListInvoicesResp, error)
	GetInvoiceAsPDF(context.Context, *GetInvoiceAsPDFReq) (*GetInvoiceAsPDFResp, error)
	// PRODUCTS
	ListProducts(context.Context, *ListProductsReq) (*ListProductsResp, error)
	// INERNAL MGMT
	GetQuayCredentials(context.Context, *GetQuayCredentialsReq) (*GetQuayCredentialsResp, error)
	SetQuayCredentials(context.Context, *SetQuayCredentialsReq) (*SetQuayCredentialsResp, error)
	ConvertExternallyCreatedAccounts(context.Context, *ConvertExternallyCreatedAccountsReq) (*ConvertExternallyCreatedAccountsResp, error)
	CreateLicense(context.Context, *CreateLicenseReq) (*CreateLicenseResp, error)
	GetAssets(context.Context, *GetAssetsReq) (*GetAssetsResp, error)
}

func RegisterAccountServiceServer(s *grpc.Server, srv AccountServiceServer) {
	s.RegisterService(&_AccountService_serviceDesc, srv)
}

func _AccountService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(CreateUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).CreateUser(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).GetUser(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_InviteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(InviteUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).InviteUser(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_AcceptUserInvitation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AcceptUserInvitationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).AcceptUserInvitation(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_AcceptAllUserInvitations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AcceptAllUserInvitationsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).AcceptAllUserInvitations(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_RevokeUserAccountAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RevokeUserAccountAccessReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).RevokeUserAccountAccess(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_ChangeUserRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChangeUserRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).ChangeUserRole(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_ListAccountUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ListAccountUsersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).ListAccountUsers(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_GetAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetAccountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).GetAccount(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_ListAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ListAccountsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).ListAccounts(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_CreateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(CreateAccountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).CreateAccount(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_RetireAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RetireAccountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).RetireAccount(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_UpsertAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UpsertAccountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).UpsertAccount(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_GetAccountStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetAccountStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).GetAccountStatus(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_TerminateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TerminateAccountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).TerminateAccount(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_AdvanceAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AdvanceAccountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).AdvanceAccount(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_UpdateProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UpdateProfileReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).UpdateProfile(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_CreateAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(CreateAddressReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).CreateAddress(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_UpdateAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UpdateAddressReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).UpdateAddress(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_UpsertAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UpsertAddressReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).UpsertAddress(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_CreateCreditCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(CreateCreditCardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).CreateCreditCard(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_GetCreditCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetCreditCardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).GetCreditCard(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_ListSubscriptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ListSubscriptionsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).ListSubscriptions(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_CreateSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(CreateSubscriptionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).CreateSubscription(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_CancelSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(CancelSubscriptionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).CancelSubscription(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_UncancelSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UncancelSubscriptionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).UncancelSubscription(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_GetInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetInvoiceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).GetInvoice(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_ListInvoices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ListInvoicesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).ListInvoices(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_GetInvoiceAsPDF_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetInvoiceAsPDFReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).GetInvoiceAsPDF(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_ListProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ListProductsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).ListProducts(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_GetQuayCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetQuayCredentialsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).GetQuayCredentials(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_SetQuayCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SetQuayCredentialsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).SetQuayCredentials(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_ConvertExternallyCreatedAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ConvertExternallyCreatedAccountsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).ConvertExternallyCreatedAccounts(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_CreateLicense_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(CreateLicenseReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).CreateLicense(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _AccountService_GetAssets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(GetAssetsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountServiceServer).GetAssets(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _AccountService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.AccountService",
	HandlerType: (*AccountServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _AccountService_CreateUser_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _AccountService_GetUser_Handler,
		},
		{
			MethodName: "InviteUser",
			Handler:    _AccountService_InviteUser_Handler,
		},
		{
			MethodName: "AcceptUserInvitation",
			Handler:    _AccountService_AcceptUserInvitation_Handler,
		},
		{
			MethodName: "AcceptAllUserInvitations",
			Handler:    _AccountService_AcceptAllUserInvitations_Handler,
		},
		{
			MethodName: "RevokeUserAccountAccess",
			Handler:    _AccountService_RevokeUserAccountAccess_Handler,
		},
		{
			MethodName: "ChangeUserRole",
			Handler:    _AccountService_ChangeUserRole_Handler,
		},
		{
			MethodName: "ListAccountUsers",
			Handler:    _AccountService_ListAccountUsers_Handler,
		},
		{
			MethodName: "GetAccount",
			Handler:    _AccountService_GetAccount_Handler,
		},
		{
			MethodName: "ListAccounts",
			Handler:    _AccountService_ListAccounts_Handler,
		},
		{
			MethodName: "CreateAccount",
			Handler:    _AccountService_CreateAccount_Handler,
		},
		{
			MethodName: "RetireAccount",
			Handler:    _AccountService_RetireAccount_Handler,
		},
		{
			MethodName: "UpsertAccount",
			Handler:    _AccountService_UpsertAccount_Handler,
		},
		{
			MethodName: "GetAccountStatus",
			Handler:    _AccountService_GetAccountStatus_Handler,
		},
		{
			MethodName: "TerminateAccount",
			Handler:    _AccountService_TerminateAccount_Handler,
		},
		{
			MethodName: "AdvanceAccount",
			Handler:    _AccountService_AdvanceAccount_Handler,
		},
		{
			MethodName: "UpdateProfile",
			Handler:    _AccountService_UpdateProfile_Handler,
		},
		{
			MethodName: "CreateAddress",
			Handler:    _AccountService_CreateAddress_Handler,
		},
		{
			MethodName: "UpdateAddress",
			Handler:    _AccountService_UpdateAddress_Handler,
		},
		{
			MethodName: "UpsertAddress",
			Handler:    _AccountService_UpsertAddress_Handler,
		},
		{
			MethodName: "CreateCreditCard",
			Handler:    _AccountService_CreateCreditCard_Handler,
		},
		{
			MethodName: "GetCreditCard",
			Handler:    _AccountService_GetCreditCard_Handler,
		},
		{
			MethodName: "ListSubscriptions",
			Handler:    _AccountService_ListSubscriptions_Handler,
		},
		{
			MethodName: "CreateSubscription",
			Handler:    _AccountService_CreateSubscription_Handler,
		},
		{
			MethodName: "CancelSubscription",
			Handler:    _AccountService_CancelSubscription_Handler,
		},
		{
			MethodName: "UncancelSubscription",
			Handler:    _AccountService_UncancelSubscription_Handler,
		},
		{
			MethodName: "GetInvoice",
			Handler:    _AccountService_GetInvoice_Handler,
		},
		{
			MethodName: "ListInvoices",
			Handler:    _AccountService_ListInvoices_Handler,
		},
		{
			MethodName: "GetInvoiceAsPDF",
			Handler:    _AccountService_GetInvoiceAsPDF_Handler,
		},
		{
			MethodName: "ListProducts",
			Handler:    _AccountService_ListProducts_Handler,
		},
		{
			MethodName: "GetQuayCredentials",
			Handler:    _AccountService_GetQuayCredentials_Handler,
		},
		{
			MethodName: "SetQuayCredentials",
			Handler:    _AccountService_SetQuayCredentials_Handler,
		},
		{
			MethodName: "ConvertExternallyCreatedAccounts",
			Handler:    _AccountService_ConvertExternallyCreatedAccounts_Handler,
		},
		{
			MethodName: "CreateLicense",
			Handler:    _AccountService_CreateLicense_Handler,
		},
		{
			MethodName: "GetAssets",
			Handler:    _AccountService_GetAssets_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

func (m *CreditCard) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreditCard) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.AccountID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	if len(m.LastFour) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.LastFour)))
		i += copy(data[i:], m.LastFour)
	}
	if m.ExpiryMonth != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAccount(data, i, uint64(m.ExpiryMonth))
	}
	if m.ExpiryYear != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAccount(data, i, uint64(m.ExpiryYear))
	}
	if len(m.Type) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.State != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAccount(data, i, uint64(m.State))
	}
	if len(m.StateDescription) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.StateDescription)))
		i += copy(data[i:], m.StateDescription)
	}
	return i, nil
}

func (m *CreateCreditCardReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateCreditCardReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Token)))
		i += copy(data[i:], m.Token)
	}
	if len(m.AccountID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	return i, nil
}

func (m *CreateCreditCardResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateCreditCardResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Card != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.Card.Size()))
		n1, err := m.Card.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *GetCreditCardReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetCreditCardReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	return i, nil
}

func (m *GetCreditCardResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetCreditCardResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Card != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.Card.Size()))
		n2, err := m.Card.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *ListProductsReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListProductsReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IncludeDeleted {
		data[i] = 0x8
		i++
		if m.IncludeDeleted {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.IncludePrivate {
		data[i] = 0x10
		i++
		if m.IncludePrivate {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ListProductsResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListProductsResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0xa
			i++
			i = encodeVarintAccount(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Product) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Product) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.Name) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.PublicName) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.PublicName)))
		i += copy(data[i:], m.PublicName)
	}
	if len(m.Description) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if m.Duration != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAccount(data, i, uint64(m.Duration))
	}
	if len(m.DurationPeriod) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.DurationPeriod)))
		i += copy(data[i:], m.DurationPeriod)
	}
	if m.Trial != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintAccount(data, i, uint64(m.Trial))
	}
	if len(m.TrialPeriod) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.TrialPeriod)))
		i += copy(data[i:], m.TrialPeriod)
	}
	if len(m.ProductType) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ProductType)))
		i += copy(data[i:], m.ProductType)
	}
	if m.Deleted {
		data[i] = 0x60
		i++
		if m.Deleted {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Public {
		data[i] = 0x68
		i++
		if m.Public {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.ExternalLink) > 0 {
		data[i] = 0x72
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ExternalLink)))
		i += copy(data[i:], m.ExternalLink)
	}
	if len(m.TOSLink) > 0 {
		data[i] = 0x7a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.TOSLink)))
		i += copy(data[i:], m.TOSLink)
	}
	if len(m.QuickstartLink) > 0 {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.QuickstartLink)))
		i += copy(data[i:], m.QuickstartLink)
	}
	if m.Order != 0 {
		data[i] = 0x88
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAccount(data, i, uint64(m.Order))
	}
	if len(m.RatePlans) > 0 {
		for _, msg := range m.RatePlans {
			data[i] = 0x92
			i++
			data[i] = 0x1
			i++
			i = encodeVarintAccount(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RatePlan) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RatePlan) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.Name) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.PublicName) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.PublicName)))
		i += copy(data[i:], m.PublicName)
	}
	if len(m.Description) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if m.Duration != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAccount(data, i, uint64(m.Duration))
	}
	if len(m.DurationPeriod) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.DurationPeriod)))
		i += copy(data[i:], m.DurationPeriod)
	}
	if m.Trial != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAccount(data, i, uint64(m.Trial))
	}
	if len(m.TrialPeriod) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.TrialPeriod)))
		i += copy(data[i:], m.TrialPeriod)
	}
	if m.Public {
		data[i] = 0x48
		i++
		if m.Public {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Purchasable {
		data[i] = 0x50
		i++
		if m.Purchasable {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.ProductID) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ProductID)))
		i += copy(data[i:], m.ProductID)
	}
	if m.BypassPaymentVerification {
		data[i] = 0x60
		i++
		if m.BypassPaymentVerification {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Order != 0 {
		data[i] = 0x68
		i++
		i = encodeVarintAccount(data, i, uint64(m.Order))
	}
	if len(m.PricingComponents) > 0 {
		for _, msg := range m.PricingComponents {
			data[i] = 0x72
			i++
			i = encodeVarintAccount(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.QuayTeams) > 0 {
		for _, s := range m.QuayTeams {
			data[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.FailedPaymentBehaviour) > 0 {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.FailedPaymentBehaviour)))
		i += copy(data[i:], m.FailedPaymentBehaviour)
	}
	return i, nil
}

func (m *PricingComponent) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PricingComponent) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.ID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.PublicName) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.PublicName)))
		i += copy(data[i:], m.PublicName)
	}
	if len(m.Description) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if m.DefaultQuantity != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAccount(data, i, uint64(m.DefaultQuantity))
	}
	if m.MinQuantity != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAccount(data, i, uint64(m.MinQuantity))
	}
	if len(m.Tiers) > 0 {
		for _, msg := range m.Tiers {
			data[i] = 0x42
			i++
			i = encodeVarintAccount(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.UnitOfMeasure != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintAccount(data, i, uint64(m.UnitOfMeasure.Size()))
		n3, err := m.UnitOfMeasure.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *PricingComponentTiers) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PricingComponentTiers) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if m.LowerThreshold != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAccount(data, i, uint64(m.LowerThreshold))
	}
	if m.UpperThreshold != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAccount(data, i, uint64(m.UpperThreshold))
	}
	if len(m.PricingType) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.PricingType)))
		i += copy(data[i:], m.PricingType)
	}
	if m.Price != 0 {
		data[i] = 0x29
		i++
		i = encodeFixed64Account(data, i, uint64(math.Float64bits(float64(m.Price))))
	}
	return i, nil
}

func (m *UnitOfMeasure) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UnitOfMeasure) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.Name) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.DisplayedAs) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.DisplayedAs)))
		i += copy(data[i:], m.DisplayedAs)
	}
	return i, nil
}

func (m *ListInvoicesReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListInvoicesReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	return i, nil
}

func (m *ListInvoicesResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListInvoicesResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Invoices) > 0 {
		for _, msg := range m.Invoices {
			data[i] = 0xa
			i++
			i = encodeVarintAccount(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetInvoiceReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetInvoiceReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InvoiceID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.InvoiceID)))
		i += copy(data[i:], m.InvoiceID)
	}
	return i, nil
}

func (m *GetInvoiceResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetInvoiceResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Invoice != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.Invoice.Size()))
		n4, err := m.Invoice.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *Invoice) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Invoice) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.Name) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.SubscriptionID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.SubscriptionID)))
		i += copy(data[i:], m.SubscriptionID)
	}
	if len(m.AccountID) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	if len(m.Type) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.State) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.State)))
		i += copy(data[i:], m.State)
	}
	if len(m.PeriodStart) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.PeriodStart)))
		i += copy(data[i:], m.PeriodStart)
	}
	if len(m.PeriodEnd) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.PeriodEnd)))
		i += copy(data[i:], m.PeriodEnd)
	}
	if len(m.Issued) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Issued)))
		i += copy(data[i:], m.Issued)
	}
	if m.InvoiceCost != 0 {
		data[i] = 0x51
		i++
		i = encodeFixed64Account(data, i, uint64(math.Float64bits(float64(m.InvoiceCost))))
	}
	if m.InvoicePaid != 0 {
		data[i] = 0x59
		i++
		i = encodeFixed64Account(data, i, uint64(math.Float64bits(float64(m.InvoicePaid))))
	}
	if m.DiscountAmount != 0 {
		data[i] = 0x61
		i++
		i = encodeFixed64Account(data, i, uint64(math.Float64bits(float64(m.DiscountAmount))))
	}
	if m.NonDiscountedCost != 0 {
		data[i] = 0x69
		i++
		i = encodeFixed64Account(data, i, uint64(math.Float64bits(float64(m.NonDiscountedCost))))
	}
	if len(m.PaymentReceived) > 0 {
		data[i] = 0x72
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.PaymentReceived)))
		i += copy(data[i:], m.PaymentReceived)
	}
	if m.InitialInvoice {
		data[i] = 0x78
		i++
		if m.InitialInvoice {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.TotalExecutionAttempts != 0 {
		data[i] = 0x80
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAccount(data, i, uint64(m.TotalExecutionAttempts))
	}
	if len(m.Currency) > 0 {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Currency)))
		i += copy(data[i:], m.Currency)
	}
	return i, nil
}

func (m *GetInvoiceAsPDFReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetInvoiceAsPDFReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.InvoiceID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.InvoiceID)))
		i += copy(data[i:], m.InvoiceID)
	}
	return i, nil
}

func (m *GetInvoiceAsPDFResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetInvoiceAsPDFResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InvoiceData != nil {
		if len(m.InvoiceData) > 0 {
			data[i] = 0xa
			i++
			i = encodeVarintAccount(data, i, uint64(len(m.InvoiceData)))
			i += copy(data[i:], m.InvoiceData)
		}
	}
	return i, nil
}

func (m *CreateUserReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateUserReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DexID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.DexID)))
		i += copy(data[i:], m.DexID)
	}
	if len(m.Email) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	return i, nil
}

func (m *CreateUserResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateUserResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.User != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.User.Size()))
		n5, err := m.User.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *GetUserReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetUserReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DexID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.DexID)))
		i += copy(data[i:], m.DexID)
	}
	return i, nil
}

func (m *GetUserResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetUserResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.User != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.User.Size()))
		n6, err := m.User.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *ListAccountUsersReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListAccountUsersReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	return i, nil
}

func (m *ListAccountUsersResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListAccountUsersResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0xa
			i++
			i = encodeVarintAccount(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InviteUserReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InviteUserReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	if len(m.AccountID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	if m.Role != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAccount(data, i, uint64(m.Role))
	}
	return i, nil
}

func (m *InviteUserResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *InviteUserResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AcceptUserInvitationReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AcceptUserInvitationReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	return i, nil
}

func (m *AcceptUserInvitationResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AcceptUserInvitationResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AcceptAllUserInvitationsReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AcceptAllUserInvitationsReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DexID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.DexID)))
		i += copy(data[i:], m.DexID)
	}
	return i, nil
}

func (m *AcceptAllUserInvitationsResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AcceptAllUserInvitationsResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RevokeUserAccountAccessReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RevokeUserAccountAccessReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ExistingMemberDexID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ExistingMemberDexID)))
		i += copy(data[i:], m.ExistingMemberDexID)
	}
	if len(m.InvitedUserEmail) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.InvitedUserEmail)))
		i += copy(data[i:], m.InvitedUserEmail)
	}
	if len(m.AccountID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	return i, nil
}

func (m *ChangeUserRoleReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangeUserRoleReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DexID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.DexID)))
		i += copy(data[i:], m.DexID)
	}
	if len(m.AccountID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	if m.Role != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAccount(data, i, uint64(m.Role))
	}
	return i, nil
}

func (m *ChangeUserRoleResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangeUserRoleResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RevokeUserAccountAccessResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RevokeUserAccountAccessResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetAccountReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetAccountReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	return i, nil
}

func (m *GetAccountResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetAccountResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Account != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.Account.Size()))
		n7, err := m.Account.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Subscriptions) > 0 {
		for _, msg := range m.Subscriptions {
			data[i] = 0x12
			i++
			i = encodeVarintAccount(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ListAccountsReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListAccountsReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ListAccountsResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListAccountsResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0xa
			i++
			i = encodeVarintAccount(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreateAccountReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateAccountReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Account != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.Account.Size()))
		n8, err := m.Account.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *CreateAccountResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateAccountResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Account != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.Account.Size()))
		n9, err := m.Account.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *UpdateProfileReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UpdateProfileReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Profile != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.Profile.Size()))
		n10, err := m.Profile.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *UpdateProfileResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UpdateProfileResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Profile != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.Profile.Size()))
		n11, err := m.Profile.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *CreateAddressReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateAddressReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.Address.Size()))
		n12, err := m.Address.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *CreateAddressResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateAddressResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.Address.Size()))
		n13, err := m.Address.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *UpdateAddressReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UpdateAddressReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.Address.Size()))
		n14, err := m.Address.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *UpdateAddressResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UpdateAddressResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.Address.Size()))
		n15, err := m.Address.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *UpsertAddressReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UpsertAddressReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.Address.Size()))
		n16, err := m.Address.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *UpsertAddressResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UpsertAddressResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.Address.Size()))
		n17, err := m.Address.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *RetireAccountReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RetireAccountReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	return i, nil
}

func (m *UpsertAccountReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UpsertAccountReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Account != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.Account.Size()))
		n18, err := m.Account.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *UpsertAccountResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UpsertAccountResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Account != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.Account.Size()))
		n19, err := m.Account.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *RetireAccountResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RetireAccountResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Retired {
		data[i] = 0x8
		i++
		if m.Retired {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ConvertExternallyCreatedAccountsReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ConvertExternallyCreatedAccountsReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DexID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.DexID)))
		i += copy(data[i:], m.DexID)
	}
	if len(m.Email) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	return i, nil
}

func (m *ConvertExternallyCreatedAccountsResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ConvertExternallyCreatedAccountsResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ConvertedAccountIDs) > 0 {
		for _, s := range m.ConvertedAccountIDs {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *Profile) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Profile) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.AccountID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	if len(m.CompanyName) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.CompanyName)))
		i += copy(data[i:], m.CompanyName)
	}
	if len(m.Email) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	if len(m.FirstName) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.FirstName)))
		i += copy(data[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.LastName)))
		i += copy(data[i:], m.LastName)
	}
	if len(m.Landline) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Landline)))
		i += copy(data[i:], m.Landline)
	}
	if len(m.Mobile) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Mobile)))
		i += copy(data[i:], m.Mobile)
	}
	if len(m.Addresses) > 0 {
		for _, msg := range m.Addresses {
			data[i] = 0x4a
			i++
			i = encodeVarintAccount(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Address) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Address) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.AddressLine1) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AddressLine1)))
		i += copy(data[i:], m.AddressLine1)
	}
	if len(m.AddressLine2) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AddressLine2)))
		i += copy(data[i:], m.AddressLine2)
	}
	if len(m.AddressLine3) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AddressLine3)))
		i += copy(data[i:], m.AddressLine3)
	}
	if len(m.City) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.City)))
		i += copy(data[i:], m.City)
	}
	if len(m.Province) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Province)))
		i += copy(data[i:], m.Province)
	}
	if len(m.Country) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Country)))
		i += copy(data[i:], m.Country)
	}
	if len(m.Postcode) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Postcode)))
		i += copy(data[i:], m.Postcode)
	}
	if len(m.Landline) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Landline)))
		i += copy(data[i:], m.Landline)
	}
	if len(m.ProfileID) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ProfileID)))
		i += copy(data[i:], m.ProfileID)
	}
	if m.PrimaryAddress {
		data[i] = 0x58
		i++
		if m.PrimaryAddress {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Account) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Account) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if m.Profile != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(m.Profile.Size()))
		n20, err := m.Profile.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.QuayID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.QuayID)))
		i += copy(data[i:], m.QuayID)
	}
	if m.NewsletterEmail {
		data[i] = 0x20
		i++
		if m.NewsletterEmail {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Deleted {
		data[i] = 0x28
		i++
		if m.Deleted {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.CreatedAt != nil {
		data[i] = 0x32
		i++
		i = encodeVarintAccount(data, i, uint64(m.CreatedAt.Size()))
		n21, err := m.CreatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *Subscription) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Subscription) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.VersionID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.VersionID)))
		i += copy(data[i:], m.VersionID)
	}
	if len(m.AccountID) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	if len(m.ProductID) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ProductID)))
		i += copy(data[i:], m.ProductID)
	}
	if len(m.ProductRatePlanID) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ProductRatePlanID)))
		i += copy(data[i:], m.ProductRatePlanID)
	}
	if len(m.Name) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.State != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAccount(data, i, uint64(m.State))
	}
	if len(m.StateDescription) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.StateDescription)))
		i += copy(data[i:], m.StateDescription)
	}
	if m.StateSeverity != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintAccount(data, i, uint64(m.StateSeverity))
	}
	if m.CurrentPeriodStart != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintAccount(data, i, uint64(m.CurrentPeriodStart.Size()))
		n22, err := m.CurrentPeriodStart.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.CurrentPeriodEnd != nil {
		data[i] = 0x62
		i++
		i = encodeVarintAccount(data, i, uint64(m.CurrentPeriodEnd.Size()))
		n23, err := m.CurrentPeriodEnd.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.InitialPeriodStart != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintAccount(data, i, uint64(m.InitialPeriodStart.Size()))
		n24, err := m.InitialPeriodStart.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.TrialEnd != nil {
		data[i] = 0x72
		i++
		i = encodeVarintAccount(data, i, uint64(m.TrialEnd.Size()))
		n25, err := m.TrialEnd.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.SubscriptionEnd != nil {
		data[i] = 0x7a
		i++
		i = encodeVarintAccount(data, i, uint64(m.SubscriptionEnd.Size()))
		n26, err := m.SubscriptionEnd.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.ContractStart != nil {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAccount(data, i, uint64(m.ContractStart.Size()))
		n27, err := m.ContractStart.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.SuccessfulPeriods != 0 {
		data[i] = 0x88
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAccount(data, i, uint64(m.SuccessfulPeriods))
	}
	if m.TotalPeriods != 0 {
		data[i] = 0x90
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAccount(data, i, uint64(m.TotalPeriods))
	}
	if m.CreditEnabled {
		data[i] = 0x98
		i++
		data[i] = 0x1
		i++
		if m.CreditEnabled {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Product != nil {
		data[i] = 0xa2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAccount(data, i, uint64(m.Product.Size()))
		n28, err := m.Product.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.RatePlan != nil {
		data[i] = 0xaa
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAccount(data, i, uint64(m.RatePlan.Size()))
		n29, err := m.RatePlan.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.Aggregating {
		data[i] = 0xb0
		i++
		data[i] = 0x1
		i++
		if m.Aggregating {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Type != 0 {
		data[i] = 0xb8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAccount(data, i, uint64(m.Type))
	}
	if m.AgreedTOS {
		data[i] = 0xc0
		i++
		data[i] = 0x1
		i++
		if m.AgreedTOS {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.PaymentType != 0 {
		data[i] = 0xc8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAccount(data, i, uint64(m.PaymentType))
	}
	if m.BypassPaymentVerification {
		data[i] = 0xd0
		i++
		data[i] = 0x1
		i++
		if m.BypassPaymentVerification {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.ChangelogEmails {
		data[i] = 0xd8
		i++
		data[i] = 0x1
		i++
		if m.ChangelogEmails {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.PricingComponentValues) > 0 {
		for _, msg := range m.PricingComponentValues {
			data[i] = 0xe2
			i++
			data[i] = 0x1
			i++
			i = encodeVarintAccount(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.FailedPaymentBehaviour) > 0 {
		data[i] = 0xea
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.FailedPaymentBehaviour)))
		i += copy(data[i:], m.FailedPaymentBehaviour)
	}
	return i, nil
}

func (m *PricingComponentValue) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PricingComponentValue) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PricingComponentID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.PricingComponentID)))
		i += copy(data[i:], m.PricingComponentID)
	}
	if len(m.PricingComponentName) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.PricingComponentName)))
		i += copy(data[i:], m.PricingComponentName)
	}
	if m.Value != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAccount(data, i, uint64(m.Value))
	}
	if m.PricingComponentInfo != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintAccount(data, i, uint64(m.PricingComponentInfo.Size()))
		n30, err := m.PricingComponentInfo.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func (m *PricingComponentValue_PricingComponentInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PricingComponentValue_PricingComponentInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PublicName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.PublicName)))
		i += copy(data[i:], m.PublicName)
	}
	if len(m.Description) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if m.InferredFromDefault {
		data[i] = 0x18
		i++
		if m.InferredFromDefault {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.UnitOfMeasure != nil {
		data[i] = 0x22
		i++
		i = encodeVarintAccount(data, i, uint64(m.UnitOfMeasure.Size()))
		n31, err := m.UnitOfMeasure.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *RoleValue) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RoleValue) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAccount(data, i, uint64(m.Value))
	}
	return i, nil
}

func (m *User) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *User) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DexID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.DexID)))
		i += copy(data[i:], m.DexID)
	}
	if len(m.Email) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	if len(m.AccountRoles) > 0 {
		for _, msg := range m.AccountRoles {
			data[i] = 0x1a
			i++
			i = encodeVarintAccount(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *User_AccountRole) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *User_AccountRole) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	if m.Role != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(m.Role.Size()))
		n32, err := m.Role.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *UserListUser) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserListUser) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DexID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.DexID)))
		i += copy(data[i:], m.DexID)
	}
	if len(m.Email) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	if m.Role != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAccount(data, i, uint64(m.Role))
	}
	return i, nil
}

func (m *PricingComponentQuantity) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PricingComponentQuantity) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PricingComponent) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.PricingComponent)))
		i += copy(data[i:], m.PricingComponent)
	}
	if m.Quantity != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAccount(data, i, uint64(m.Quantity))
	}
	return i, nil
}

func (m *CreateSubscriptionReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateSubscriptionReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	if len(m.ProductID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ProductID)))
		i += copy(data[i:], m.ProductID)
	}
	if len(m.ProductRatePlanID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.ProductRatePlanID)))
		i += copy(data[i:], m.ProductRatePlanID)
	}
	if m.AgreedTOS {
		data[i] = 0x20
		i++
		if m.AgreedTOS {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.ChangelogEmails {
		data[i] = 0x28
		i++
		if m.ChangelogEmails {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.PaymentType != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAccount(data, i, uint64(m.PaymentType))
	}
	if m.State != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAccount(data, i, uint64(m.State))
	}
	if len(m.PricingComponentQuantities) > 0 {
		for _, msg := range m.PricingComponentQuantities {
			data[i] = 0x42
			i++
			i = encodeVarintAccount(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreateSubscriptionResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateSubscriptionResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Subscription != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.Subscription.Size()))
		n33, err := m.Subscription.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *CancelSubscriptionReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CancelSubscriptionReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SubscriptionID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.SubscriptionID)))
		i += copy(data[i:], m.SubscriptionID)
	}
	if len(m.AccountID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	if len(m.Reason) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Reason)))
		i += copy(data[i:], m.Reason)
	}
	return i, nil
}

func (m *CancelSubscriptionResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CancelSubscriptionResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *UncancelSubscriptionReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UncancelSubscriptionReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SubscriptionID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.SubscriptionID)))
		i += copy(data[i:], m.SubscriptionID)
	}
	if len(m.AccountID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	return i, nil
}

func (m *UncancelSubscriptionResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UncancelSubscriptionResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ListSubscriptionsReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListSubscriptionsReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	if m.IncludeRetired {
		data[i] = 0x10
		i++
		if m.IncludeRetired {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ListSubscriptionsResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListSubscriptionsResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Parent != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(m.Parent.Size()))
		n34, err := m.Parent.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			data[i] = 0x12
			i++
			i = encodeVarintAccount(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SetQuayCredentialsReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetQuayCredentialsReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	if len(m.QuayID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.QuayID)))
		i += copy(data[i:], m.QuayID)
	}
	if len(m.QuayToken) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.QuayToken)))
		i += copy(data[i:], m.QuayToken)
	}
	return i, nil
}

func (m *SetQuayCredentialsResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetQuayCredentialsResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetQuayCredentialsReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetQuayCredentialsReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	return i, nil
}

func (m *GetQuayCredentialsResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetQuayCredentialsResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.QuayID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.QuayID)))
		i += copy(data[i:], m.QuayID)
	}
	if len(m.QuayToken) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.QuayToken)))
		i += copy(data[i:], m.QuayToken)
	}
	return i, nil
}

func (m *GetAssetsReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetAssetsReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	return i, nil
}

func (m *GetAssetsResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetAssetsResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Assets) > 0 {
		for k, _ := range m.Assets {
			data[i] = 0xa
			i++
			v := m.Assets[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovAccount(uint64(len(k))) + 1 + msgSize + sovAccount(uint64(msgSize))
			i = encodeVarintAccount(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAccount(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintAccount(data, i, uint64(v.Size()))
			n35, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n35
		}
	}
	return i, nil
}

func (m *Asset) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Asset) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Label) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Label)))
		i += copy(data[i:], m.Label)
	}
	if len(m.Formats) > 0 {
		for k, _ := range m.Formats {
			data[i] = 0x12
			i++
			v := m.Formats[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovAccount(uint64(len(k))) + 1 + msgSize + sovAccount(uint64(msgSize))
			i = encodeVarintAccount(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAccount(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintAccount(data, i, uint64(v.Size()))
			n36, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n36
		}
	}
	return i, nil
}

func (m *OutputFormat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OutputFormat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Label) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Label)))
		i += copy(data[i:], m.Label)
	}
	if len(m.Value) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	if len(m.Type) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Filename) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.Filename)))
		i += copy(data[i:], m.Filename)
	}
	return i, nil
}

func (m *CreateLicenseReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateLicenseReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	return i, nil
}

func (m *CreateLicenseResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateLicenseResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetAccountStatusReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetAccountStatusReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	return i, nil
}

func (m *GetAccountStatusResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetAccountStatusResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Balance != 0 {
		data[i] = 0x9
		i++
		i = encodeFixed64Account(data, i, uint64(math.Float64bits(float64(m.Balance))))
	}
	if m.Status != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAccount(data, i, uint64(m.Status))
	}
	if len(m.StatusDescription) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.StatusDescription)))
		i += copy(data[i:], m.StatusDescription)
	}
	if m.NextInvoiceDate != nil {
		data[i] = 0x22
		i++
		i = encodeVarintAccount(data, i, uint64(m.NextInvoiceDate.Size()))
		n37, err := m.NextInvoiceDate.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if len(m.PurchasedProductIDs) > 0 {
		for _, s := range m.PurchasedProductIDs {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *TerminateAccountReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TerminateAccountReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	return i, nil
}

func (m *TerminateAccountResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TerminateAccountResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *AdvanceAccountReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AdvanceAccountReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAccount(data, i, uint64(len(m.AccountID)))
		i += copy(data[i:], m.AccountID)
	}
	if m.Periods != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAccount(data, i, uint64(m.Periods))
	}
	return i, nil
}

func (m *AdvanceAccountResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AdvanceAccountResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeFixed64Account(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Account(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintAccount(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *CreditCard) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.LastFour)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.ExpiryMonth != 0 {
		n += 1 + sovAccount(uint64(m.ExpiryMonth))
	}
	if m.ExpiryYear != 0 {
		n += 1 + sovAccount(uint64(m.ExpiryYear))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovAccount(uint64(m.State))
	}
	l = len(m.StateDescription)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *CreateCreditCardReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *CreateCreditCardResp) Size() (n int) {
	var l int
	_ = l
	if m.Card != nil {
		l = m.Card.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *GetCreditCardReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *GetCreditCardResp) Size() (n int) {
	var l int
	_ = l
	if m.Card != nil {
		l = m.Card.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *ListProductsReq) Size() (n int) {
	var l int
	_ = l
	if m.IncludeDeleted {
		n += 2
	}
	if m.IncludePrivate {
		n += 2
	}
	return n
}

func (m *ListProductsResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAccount(uint64(l))
		}
	}
	return n
}

func (m *Product) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.PublicName)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovAccount(uint64(m.Duration))
	}
	l = len(m.DurationPeriod)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Trial != 0 {
		n += 1 + sovAccount(uint64(m.Trial))
	}
	l = len(m.TrialPeriod)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.ProductType)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Deleted {
		n += 2
	}
	if m.Public {
		n += 2
	}
	l = len(m.ExternalLink)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.TOSLink)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.QuickstartLink)
	if l > 0 {
		n += 2 + l + sovAccount(uint64(l))
	}
	if m.Order != 0 {
		n += 2 + sovAccount(uint64(m.Order))
	}
	if len(m.RatePlans) > 0 {
		for _, e := range m.RatePlans {
			l = e.Size()
			n += 2 + l + sovAccount(uint64(l))
		}
	}
	return n
}

func (m *RatePlan) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.PublicName)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovAccount(uint64(m.Duration))
	}
	l = len(m.DurationPeriod)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Trial != 0 {
		n += 1 + sovAccount(uint64(m.Trial))
	}
	l = len(m.TrialPeriod)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Public {
		n += 2
	}
	if m.Purchasable {
		n += 2
	}
	l = len(m.ProductID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.BypassPaymentVerification {
		n += 2
	}
	if m.Order != 0 {
		n += 1 + sovAccount(uint64(m.Order))
	}
	if len(m.PricingComponents) > 0 {
		for _, e := range m.PricingComponents {
			l = e.Size()
			n += 1 + l + sovAccount(uint64(l))
		}
	}
	if len(m.QuayTeams) > 0 {
		for _, s := range m.QuayTeams {
			l = len(s)
			n += 1 + l + sovAccount(uint64(l))
		}
	}
	l = len(m.FailedPaymentBehaviour)
	if l > 0 {
		n += 2 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *PricingComponent) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.PublicName)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.DefaultQuantity != 0 {
		n += 1 + sovAccount(uint64(m.DefaultQuantity))
	}
	if m.MinQuantity != 0 {
		n += 1 + sovAccount(uint64(m.MinQuantity))
	}
	if len(m.Tiers) > 0 {
		for _, e := range m.Tiers {
			l = e.Size()
			n += 1 + l + sovAccount(uint64(l))
		}
	}
	if m.UnitOfMeasure != nil {
		l = m.UnitOfMeasure.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *PricingComponentTiers) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.LowerThreshold != 0 {
		n += 1 + sovAccount(uint64(m.LowerThreshold))
	}
	if m.UpperThreshold != 0 {
		n += 1 + sovAccount(uint64(m.UpperThreshold))
	}
	l = len(m.PricingType)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Price != 0 {
		n += 9
	}
	return n
}

func (m *UnitOfMeasure) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.DisplayedAs)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *ListInvoicesReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *ListInvoicesResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Invoices) > 0 {
		for _, e := range m.Invoices {
			l = e.Size()
			n += 1 + l + sovAccount(uint64(l))
		}
	}
	return n
}

func (m *GetInvoiceReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.InvoiceID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *GetInvoiceResp) Size() (n int) {
	var l int
	_ = l
	if m.Invoice != nil {
		l = m.Invoice.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *Invoice) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.SubscriptionID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.PeriodStart)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.PeriodEnd)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Issued)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.InvoiceCost != 0 {
		n += 9
	}
	if m.InvoicePaid != 0 {
		n += 9
	}
	if m.DiscountAmount != 0 {
		n += 9
	}
	if m.NonDiscountedCost != 0 {
		n += 9
	}
	l = len(m.PaymentReceived)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.InitialInvoice {
		n += 2
	}
	if m.TotalExecutionAttempts != 0 {
		n += 2 + sovAccount(uint64(m.TotalExecutionAttempts))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 2 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *GetInvoiceAsPDFReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.InvoiceID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *GetInvoiceAsPDFResp) Size() (n int) {
	var l int
	_ = l
	if m.InvoiceData != nil {
		l = len(m.InvoiceData)
		if l > 0 {
			n += 1 + l + sovAccount(uint64(l))
		}
	}
	return n
}

func (m *CreateUserReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.DexID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *CreateUserResp) Size() (n int) {
	var l int
	_ = l
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *GetUserReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.DexID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *GetUserResp) Size() (n int) {
	var l int
	_ = l
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *ListAccountUsersReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *ListAccountUsersResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAccount(uint64(l))
		}
	}
	return n
}

func (m *InviteUserReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovAccount(uint64(m.Role))
	}
	return n
}

func (m *InviteUserResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AcceptUserInvitationReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *AcceptUserInvitationResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AcceptAllUserInvitationsReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.DexID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *AcceptAllUserInvitationsResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RevokeUserAccountAccessReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ExistingMemberDexID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.InvitedUserEmail)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *ChangeUserRoleReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.DexID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovAccount(uint64(m.Role))
	}
	return n
}

func (m *ChangeUserRoleResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RevokeUserAccountAccessResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetAccountReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *GetAccountResp) Size() (n int) {
	var l int
	_ = l
	if m.Account != nil {
		l = m.Account.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	if len(m.Subscriptions) > 0 {
		for _, e := range m.Subscriptions {
			l = e.Size()
			n += 1 + l + sovAccount(uint64(l))
		}
	}
	return n
}

func (m *ListAccountsReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ListAccountsResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovAccount(uint64(l))
		}
	}
	return n
}

func (m *CreateAccountReq) Size() (n int) {
	var l int
	_ = l
	if m.Account != nil {
		l = m.Account.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *CreateAccountResp) Size() (n int) {
	var l int
	_ = l
	if m.Account != nil {
		l = m.Account.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *UpdateProfileReq) Size() (n int) {
	var l int
	_ = l
	if m.Profile != nil {
		l = m.Profile.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *UpdateProfileResp) Size() (n int) {
	var l int
	_ = l
	if m.Profile != nil {
		l = m.Profile.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *CreateAddressReq) Size() (n int) {
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *CreateAddressResp) Size() (n int) {
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *UpdateAddressReq) Size() (n int) {
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *UpdateAddressResp) Size() (n int) {
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *UpsertAddressReq) Size() (n int) {
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *UpsertAddressResp) Size() (n int) {
	var l int
	_ = l
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *RetireAccountReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *UpsertAccountReq) Size() (n int) {
	var l int
	_ = l
	if m.Account != nil {
		l = m.Account.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *UpsertAccountResp) Size() (n int) {
	var l int
	_ = l
	if m.Account != nil {
		l = m.Account.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *RetireAccountResp) Size() (n int) {
	var l int
	_ = l
	if m.Retired {
		n += 2
	}
	return n
}

func (m *ConvertExternallyCreatedAccountsReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.DexID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *ConvertExternallyCreatedAccountsResp) Size() (n int) {
	var l int
	_ = l
	if len(m.ConvertedAccountIDs) > 0 {
		for _, s := range m.ConvertedAccountIDs {
			l = len(s)
			n += 1 + l + sovAccount(uint64(l))
		}
	}
	return n
}

func (m *Profile) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.CompanyName)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Landline)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Mobile)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if len(m.Addresses) > 0 {
		for _, e := range m.Addresses {
			l = e.Size()
			n += 1 + l + sovAccount(uint64(l))
		}
	}
	return n
}

func (m *Address) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.AddressLine1)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.AddressLine2)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.AddressLine3)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Province)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Postcode)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Landline)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.ProfileID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.PrimaryAddress {
		n += 2
	}
	return n
}

func (m *Account) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Profile != nil {
		l = m.Profile.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.QuayID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.NewsletterEmail {
		n += 2
	}
	if m.Deleted {
		n += 2
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *Subscription) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.VersionID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.ProductID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.ProductRatePlanID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovAccount(uint64(m.State))
	}
	l = len(m.StateDescription)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.StateSeverity != 0 {
		n += 1 + sovAccount(uint64(m.StateSeverity))
	}
	if m.CurrentPeriodStart != nil {
		l = m.CurrentPeriodStart.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.CurrentPeriodEnd != nil {
		l = m.CurrentPeriodEnd.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.InitialPeriodStart != nil {
		l = m.InitialPeriodStart.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.TrialEnd != nil {
		l = m.TrialEnd.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.SubscriptionEnd != nil {
		l = m.SubscriptionEnd.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.ContractStart != nil {
		l = m.ContractStart.Size()
		n += 2 + l + sovAccount(uint64(l))
	}
	if m.SuccessfulPeriods != 0 {
		n += 2 + sovAccount(uint64(m.SuccessfulPeriods))
	}
	if m.TotalPeriods != 0 {
		n += 2 + sovAccount(uint64(m.TotalPeriods))
	}
	if m.CreditEnabled {
		n += 3
	}
	if m.Product != nil {
		l = m.Product.Size()
		n += 2 + l + sovAccount(uint64(l))
	}
	if m.RatePlan != nil {
		l = m.RatePlan.Size()
		n += 2 + l + sovAccount(uint64(l))
	}
	if m.Aggregating {
		n += 3
	}
	if m.Type != 0 {
		n += 2 + sovAccount(uint64(m.Type))
	}
	if m.AgreedTOS {
		n += 3
	}
	if m.PaymentType != 0 {
		n += 2 + sovAccount(uint64(m.PaymentType))
	}
	if m.BypassPaymentVerification {
		n += 3
	}
	if m.ChangelogEmails {
		n += 3
	}
	if len(m.PricingComponentValues) > 0 {
		for _, e := range m.PricingComponentValues {
			l = e.Size()
			n += 2 + l + sovAccount(uint64(l))
		}
	}
	l = len(m.FailedPaymentBehaviour)
	if l > 0 {
		n += 2 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *PricingComponentValue) Size() (n int) {
	var l int
	_ = l
	l = len(m.PricingComponentID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.PricingComponentName)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovAccount(uint64(m.Value))
	}
	if m.PricingComponentInfo != nil {
		l = m.PricingComponentInfo.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *PricingComponentValue_PricingComponentInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.PublicName)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.InferredFromDefault {
		n += 2
	}
	if m.UnitOfMeasure != nil {
		l = m.UnitOfMeasure.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *RoleValue) Size() (n int) {
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovAccount(uint64(m.Value))
	}
	return n
}

func (m *User) Size() (n int) {
	var l int
	_ = l
	l = len(m.DexID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if len(m.AccountRoles) > 0 {
		for _, e := range m.AccountRoles {
			l = e.Size()
			n += 1 + l + sovAccount(uint64(l))
		}
	}
	return n
}

func (m *User_AccountRole) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Role != nil {
		l = m.Role.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *UserListUser) Size() (n int) {
	var l int
	_ = l
	l = len(m.DexID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovAccount(uint64(m.Role))
	}
	return n
}

func (m *PricingComponentQuantity) Size() (n int) {
	var l int
	_ = l
	l = len(m.PricingComponent)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Quantity != 0 {
		n += 1 + sovAccount(uint64(m.Quantity))
	}
	return n
}

func (m *CreateSubscriptionReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.ProductID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.ProductRatePlanID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.AgreedTOS {
		n += 2
	}
	if m.ChangelogEmails {
		n += 2
	}
	if m.PaymentType != 0 {
		n += 1 + sovAccount(uint64(m.PaymentType))
	}
	if m.State != 0 {
		n += 1 + sovAccount(uint64(m.State))
	}
	if len(m.PricingComponentQuantities) > 0 {
		for _, e := range m.PricingComponentQuantities {
			l = e.Size()
			n += 1 + l + sovAccount(uint64(l))
		}
	}
	return n
}

func (m *CreateSubscriptionResp) Size() (n int) {
	var l int
	_ = l
	if m.Subscription != nil {
		l = m.Subscription.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *CancelSubscriptionReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.SubscriptionID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *CancelSubscriptionResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *UncancelSubscriptionReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.SubscriptionID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *UncancelSubscriptionResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ListSubscriptionsReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.IncludeRetired {
		n += 2
	}
	return n
}

func (m *ListSubscriptionsResp) Size() (n int) {
	var l int
	_ = l
	if m.Parent != nil {
		l = m.Parent.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovAccount(uint64(l))
		}
	}
	return n
}

func (m *SetQuayCredentialsReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.QuayID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.QuayToken)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *SetQuayCredentialsResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetQuayCredentialsReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *GetQuayCredentialsResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.QuayID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.QuayToken)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *GetAssetsReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *GetAssetsResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Assets) > 0 {
		for k, v := range m.Assets {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovAccount(uint64(len(k))) + 1 + l + sovAccount(uint64(l))
			n += mapEntrySize + 1 + sovAccount(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Asset) Size() (n int) {
	var l int
	_ = l
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if len(m.Formats) > 0 {
		for k, v := range m.Formats {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovAccount(uint64(len(k))) + 1 + l + sovAccount(uint64(l))
			n += mapEntrySize + 1 + sovAccount(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *OutputFormat) Size() (n int) {
	var l int
	_ = l
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *CreateLicenseReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *CreateLicenseResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetAccountStatusReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *GetAccountStatusResp) Size() (n int) {
	var l int
	_ = l
	if m.Balance != 0 {
		n += 9
	}
	if m.Status != 0 {
		n += 1 + sovAccount(uint64(m.Status))
	}
	l = len(m.StatusDescription)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.NextInvoiceDate != nil {
		l = m.NextInvoiceDate.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	if len(m.PurchasedProductIDs) > 0 {
		for _, s := range m.PurchasedProductIDs {
			l = len(s)
			n += 1 + l + sovAccount(uint64(l))
		}
	}
	return n
}

func (m *TerminateAccountReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *TerminateAccountResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *AdvanceAccountReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Periods != 0 {
		n += 1 + sovAccount(uint64(m.Periods))
	}
	return n
}

func (m *AdvanceAccountResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovAccount(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAccount(x uint64) (n int) {
	return sovAccount(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CreditCard) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreditCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreditCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastFour", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastFour = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryMonth", wireType)
			}
			m.ExpiryMonth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ExpiryMonth |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryYear", wireType)
			}
			m.ExpiryYear = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ExpiryYear |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (CreditCard_CreditCardState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateDescription = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateCreditCardReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateCreditCardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateCreditCardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateCreditCardResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateCreditCardResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateCreditCardResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Card == nil {
				m.Card = &CreditCard{}
			}
			if err := m.Card.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCreditCardReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCreditCardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCreditCardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCreditCardResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCreditCardResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCreditCardResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Card == nil {
				m.Card = &CreditCard{}
			}
			if err := m.Card.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListProductsReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListProductsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListProductsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeDeleted = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludePrivate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludePrivate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListProductsResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListProductsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListProductsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Product{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Product) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Product: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Product: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationPeriod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DurationPeriod = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trial", wireType)
			}
			m.Trial = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Trial |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrialPeriod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrialPeriod = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deleted = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Public", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Public = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalLink = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TOSLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TOSLink = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuickstartLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuickstartLink = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Order |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RatePlans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RatePlans = append(m.RatePlans, &RatePlan{})
			if err := m.RatePlans[len(m.RatePlans)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RatePlan) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RatePlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RatePlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationPeriod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DurationPeriod = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trial", wireType)
			}
			m.Trial = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Trial |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrialPeriod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrialPeriod = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Public", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Public = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purchasable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Purchasable = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BypassPaymentVerification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BypassPaymentVerification = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Order |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricingComponents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PricingComponents = append(m.PricingComponents, &PricingComponent{})
			if err := m.PricingComponents[len(m.PricingComponents)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuayTeams", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuayTeams = append(m.QuayTeams, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedPaymentBehaviour", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedPaymentBehaviour = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PricingComponent) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PricingComponent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PricingComponent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultQuantity", wireType)
			}
			m.DefaultQuantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DefaultQuantity |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuantity", wireType)
			}
			m.MinQuantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MinQuantity |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tiers = append(m.Tiers, &PricingComponentTiers{})
			if err := m.Tiers[len(m.Tiers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitOfMeasure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnitOfMeasure == nil {
				m.UnitOfMeasure = &UnitOfMeasure{}
			}
			if err := m.UnitOfMeasure.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PricingComponentTiers) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PricingComponentTiers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PricingComponentTiers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerThreshold", wireType)
			}
			m.LowerThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LowerThreshold |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperThreshold", wireType)
			}
			m.UpperThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UpperThreshold |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricingType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PricingType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Price = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnitOfMeasure) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnitOfMeasure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnitOfMeasure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayedAs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayedAs = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListInvoicesReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListInvoicesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListInvoicesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListInvoicesResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListInvoicesResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListInvoicesResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invoices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Invoices = append(m.Invoices, &Invoice{})
			if err := m.Invoices[len(m.Invoices)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetInvoiceReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetInvoiceReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetInvoiceReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvoiceID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetInvoiceResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetInvoiceResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetInvoiceResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invoice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Invoice == nil {
				m.Invoice = &Invoice{}
			}
			if err := m.Invoice.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Invoice) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Invoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Invoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodStart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeriodStart = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodEnd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeriodEnd = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issued", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issued = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceCost", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.InvoiceCost = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoicePaid", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.InvoicePaid = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.DiscountAmount = float64(math.Float64frombits(v))
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonDiscountedCost", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.NonDiscountedCost = float64(math.Float64frombits(v))
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentReceived", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentReceived = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialInvoice", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InitialInvoice = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalExecutionAttempts", wireType)
			}
			m.TotalExecutionAttempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalExecutionAttempts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetInvoiceAsPDFReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetInvoiceAsPDFReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetInvoiceAsPDFReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvoiceID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetInvoiceAsPDFResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetInvoiceAsPDFResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetInvoiceAsPDFResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvoiceData = append(m.InvoiceData[:0], data[iNdEx:postIndex]...)
			if m.InvoiceData == nil {
				m.InvoiceData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateUserReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DexID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DexID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateUserResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateUserResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateUserResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DexID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DexID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAccountUsersReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAccountUsersReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAccountUsersReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAccountUsersResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAccountUsersResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAccountUsersResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &UserListUser{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InviteUserReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InviteUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InviteUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Role |= (Role(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InviteUserResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InviteUserResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InviteUserResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptUserInvitationReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptUserInvitationReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptUserInvitationReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptUserInvitationResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptUserInvitationResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptUserInvitationResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptAllUserInvitationsReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptAllUserInvitationsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptAllUserInvitationsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DexID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DexID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptAllUserInvitationsResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptAllUserInvitationsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptAllUserInvitationsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RevokeUserAccountAccessReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RevokeUserAccountAccessReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RevokeUserAccountAccessReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingMemberDexID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExistingMemberDexID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvitedUserEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvitedUserEmail = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeUserRoleReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeUserRoleReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeUserRoleReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DexID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DexID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Role |= (Role(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeUserRoleResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeUserRoleResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeUserRoleResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RevokeUserAccountAccessResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RevokeUserAccountAccessResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RevokeUserAccountAccessResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAccountReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAccountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAccountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAccountResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAccountResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAccountResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Account == nil {
				m.Account = &Account{}
			}
			if err := m.Account.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscriptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subscriptions = append(m.Subscriptions, &Subscription{})
			if err := m.Subscriptions[len(m.Subscriptions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAccountsReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAccountsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAccountsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAccountsResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAccountsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAccountsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Account{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAccountReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAccountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAccountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Account == nil {
				m.Account = &Account{}
			}
			if err := m.Account.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAccountResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAccountResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAccountResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Account == nil {
				m.Account = &Account{}
			}
			if err := m.Account.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateProfileReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateProfileReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateProfileReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Profile == nil {
				m.Profile = &Profile{}
			}
			if err := m.Profile.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateProfileResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateProfileResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateProfileResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Profile == nil {
				m.Profile = &Profile{}
			}
			if err := m.Profile.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAddressReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAddressReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAddressReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &Address{}
			}
			if err := m.Address.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAddressResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAddressResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAddressResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &Address{}
			}
			if err := m.Address.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateAddressReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateAddressReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateAddressReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &Address{}
			}
			if err := m.Address.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateAddressResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateAddressResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateAddressResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &Address{}
			}
			if err := m.Address.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsertAddressReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsertAddressReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsertAddressReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &Address{}
			}
			if err := m.Address.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsertAddressResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsertAddressResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsertAddressResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &Address{}
			}
			if err := m.Address.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetireAccountReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetireAccountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetireAccountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsertAccountReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsertAccountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsertAccountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Account == nil {
				m.Account = &Account{}
			}
			if err := m.Account.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpsertAccountResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpsertAccountResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpsertAccountResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Account == nil {
				m.Account = &Account{}
			}
			if err := m.Account.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetireAccountResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetireAccountResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetireAccountResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Retired = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConvertExternallyCreatedAccountsReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvertExternallyCreatedAccountsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvertExternallyCreatedAccountsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DexID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DexID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConvertExternallyCreatedAccountsResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConvertExternallyCreatedAccountsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConvertExternallyCreatedAccountsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConvertedAccountIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConvertedAccountIDs = append(m.ConvertedAccountIDs, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Profile) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Profile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Profile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompanyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompanyName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Landline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Landline = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mobile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mobile = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, &Address{})
			if err := m.Addresses[len(m.Addresses)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Address) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Address: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Address: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressLine1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressLine1 = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressLine2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressLine2 = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressLine3", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressLine3 = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Province", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Province = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Postcode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Postcode = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Landline", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Landline = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryAddress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrimaryAddress = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Account: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Account: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Profile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Profile == nil {
				m.Profile = &Profile{}
			}
			if err := m.Profile.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuayID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuayID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewsletterEmail", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewsletterEmail = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deleted = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &common.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subscription) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subscription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subscription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductRatePlanID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductRatePlanID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (SubscriptionState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateDescription = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateSeverity", wireType)
			}
			m.StateSeverity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StateSeverity |= (StateSeverity(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentPeriodStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurrentPeriodStart == nil {
				m.CurrentPeriodStart = &common.Timestamp{}
			}
			if err := m.CurrentPeriodStart.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentPeriodEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurrentPeriodEnd == nil {
				m.CurrentPeriodEnd = &common.Timestamp{}
			}
			if err := m.CurrentPeriodEnd.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialPeriodStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitialPeriodStart == nil {
				m.InitialPeriodStart = &common.Timestamp{}
			}
			if err := m.InitialPeriodStart.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrialEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrialEnd == nil {
				m.TrialEnd = &common.Timestamp{}
			}
			if err := m.TrialEnd.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubscriptionEnd == nil {
				m.SubscriptionEnd = &common.Timestamp{}
			}
			if err := m.SubscriptionEnd.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContractStart == nil {
				m.ContractStart = &common.Timestamp{}
			}
			if err := m.ContractStart.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessfulPeriods", wireType)
			}
			m.SuccessfulPeriods = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SuccessfulPeriods |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPeriods", wireType)
			}
			m.TotalPeriods = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalPeriods |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreditEnabled = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Product == nil {
				m.Product = &Product{}
			}
			if err := m.Product.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RatePlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RatePlan == nil {
				m.RatePlan = &RatePlan{}
			}
			if err := m.RatePlan.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregating", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Aggregating = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (Subscription_SubscriptionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgreedTOS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AgreedTOS = bool(v != 0)
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentType", wireType)
			}
			m.PaymentType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PaymentType |= (Subscription_PaymentType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BypassPaymentVerification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BypassPaymentVerification = bool(v != 0)
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangelogEmails", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChangelogEmails = bool(v != 0)
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricingComponentValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PricingComponentValues = append(m.PricingComponentValues, &PricingComponentValue{})
			if err := m.PricingComponentValues[len(m.PricingComponentValues)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedPaymentBehaviour", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedPaymentBehaviour = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PricingComponentValue) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PricingComponentValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PricingComponentValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricingComponentID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PricingComponentID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricingComponentName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PricingComponentName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Value |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricingComponentInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PricingComponentInfo == nil {
				m.PricingComponentInfo = &PricingComponentValue_PricingComponentInfo{}
			}
			if err := m.PricingComponentInfo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PricingComponentValue_PricingComponentInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PricingComponentInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PricingComponentInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InferredFromDefault", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InferredFromDefault = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitOfMeasure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnitOfMeasure == nil {
				m.UnitOfMeasure = &UnitOfMeasure{}
			}
			if err := m.UnitOfMeasure.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleValue) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Value |= (Role(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DexID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DexID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountRoles = append(m.AccountRoles, &User_AccountRole{})
			if err := m.AccountRoles[len(m.AccountRoles)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User_AccountRole) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountRole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountRole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Role == nil {
				m.Role = &RoleValue{}
			}
			if err := m.Role.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserListUser) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserListUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserListUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DexID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DexID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Role |= (Role(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PricingComponentQuantity) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PricingComponentQuantity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PricingComponentQuantity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricingComponent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PricingComponent = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Quantity |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSubscriptionReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSubscriptionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSubscriptionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductRatePlanID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductRatePlanID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgreedTOS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AgreedTOS = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangelogEmails", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChangelogEmails = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentType", wireType)
			}
			m.PaymentType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PaymentType |= (CreateSubscriptionReq_PaymentType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (SubscriptionState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricingComponentQuantities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PricingComponentQuantities = append(m.PricingComponentQuantities, &PricingComponentQuantity{})
			if err := m.PricingComponentQuantities[len(m.PricingComponentQuantities)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSubscriptionResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSubscriptionResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSubscriptionResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subscription", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subscription == nil {
				m.Subscription = &Subscription{}
			}
			if err := m.Subscription.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelSubscriptionReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelSubscriptionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelSubscriptionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelSubscriptionResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelSubscriptionResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelSubscriptionResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UncancelSubscriptionReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UncancelSubscriptionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UncancelSubscriptionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UncancelSubscriptionResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UncancelSubscriptionResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UncancelSubscriptionResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListSubscriptionsReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListSubscriptionsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListSubscriptionsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeRetired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeRetired = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListSubscriptionsResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListSubscriptionsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListSubscriptionsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parent == nil {
				m.Parent = &Subscription{}
			}
			if err := m.Parent.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &Subscription{})
			if err := m.Children[len(m.Children)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetQuayCredentialsReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetQuayCredentialsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetQuayCredentialsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuayID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuayID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuayToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuayToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetQuayCredentialsResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetQuayCredentialsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetQuayCredentialsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetQuayCredentialsReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetQuayCredentialsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetQuayCredentialsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetQuayCredentialsResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetQuayCredentialsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetQuayCredentialsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuayID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuayID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuayToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuayToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAssetsReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAssetsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAssetsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAssetsResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAssetsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAssetsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAccount
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthAccount
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthAccount
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &Asset{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.Assets == nil {
				m.Assets = make(map[string]*Asset)
			}
			m.Assets[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Asset) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Asset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Asset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Formats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAccount
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthAccount
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthAccount
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &OutputFormat{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.Formats == nil {
				m.Formats = make(map[string]*OutputFormat)
			}
			m.Formats[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OutputFormat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutputFormat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutputFormat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateLicenseReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateLicenseReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateLicenseReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateLicenseResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateLicenseResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateLicenseResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAccountStatusReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAccountStatusReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAccountStatusReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAccountStatusResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAccountStatusResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAccountStatusResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Balance = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Status |= (GetAccountStatusResp_AccountStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusDescription = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextInvoiceDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextInvoiceDate == nil {
				m.NextInvoiceDate = &common.Timestamp{}
			}
			if err := m.NextInvoiceDate.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PurchasedProductIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PurchasedProductIDs = append(m.PurchasedProductIDs, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TerminateAccountReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TerminateAccountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TerminateAccountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TerminateAccountResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TerminateAccountResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TerminateAccountResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvanceAccountReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvanceAccountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvanceAccountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Periods", wireType)
			}
			m.Periods = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Periods |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdvanceAccountResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdvanceAccountResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdvanceAccountResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAccount(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAccount
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAccount
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAccount(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAccount = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAccount   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorAccount = []byte{
	// 5104 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xd4, 0x3c, 0x5d, 0x8f, 0x1c, 0x49,
	0x52, 0xee, 0xee, 0xe9, 0x99, 0xe9, 0x98, 0xaf, 0x9e, 0x9c, 0xf6, 0xb8, 0xdd, 0xb6, 0xd7, 0xbb,
	0x75, 0x7b, 0xc8, 0x36, 0xbb, 0x36, 0x3b, 0xbe, 0xe3, 0xbc, 0xde, 0xfb, 0x60, 0xbe, 0x6c, 0xe6,
	0xd6, 0xf3, 0xe1, 0x9c, 0xf1, 0xae, 0x56, 0xc7, 0xd1, 0xaa, 0xe9, 0xaa, 0xb1, 0x0b, 0xf7, 0x74,
	0xb7, 0xab, 0xaa, 0x67, 0x3d, 0x48, 0x08, 0x21, 0x81, 0x4e, 0x02, 0x04, 0xd2, 0x49, 0x48, 0x27,
	0x78, 0x41, 0xe2, 0xb7, 0x20, 0x9d, 0x84, 0x84, 0xe0, 0x81, 0x17, 0x1e, 0x4e, 0xe8, 0x78, 0x83,
	0x27, 0xde, 0x78, 0x3a, 0x11, 0x19, 0x99, 0x59, 0x95, 0x95, 0x55, 0x3d, 0x1f, 0x9e, 0x41, 0x82,
	0x87, 0x99, 0xca, 0x8c, 0x88, 0x8c, 0x8c, 0xca, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c, 0x6a, 0x98, 0x71,
	0x3b, 0x9d, 0xfe, 0xb0, 0x17, 0xdf, 0x1f, 0x84, 0xfd, 0xb8, 0xcf, 0xaa, 0xf4, 0x68, 0x7d, 0xfc,
	0x32, 0x88, 0x5f, 0x0d, 0xf7, 0xef, 0x77, 0xfa, 0x87, 0x0f, 0x5e, 0xf6, 0x5f, 0xf6, 0x1f, 0x10,
	0x78, 0x7f, 0x78, 0x40, 0x35, 0xaa, 0x50, 0x49, 0xb6, 0x6a, 0xfd, 0xa6, 0x41, 0xde, 0xe9, 0x87,
	0x7e, 0x3f, 0xfa, 0x38, 0xe8, 0x75, 0x1e, 0x44, 0xfd, 0x63, 0xd9, 0x10, 0x81, 0x87, 0x87, 0xfd,
	0xde, 0x83, 0x38, 0x38, 0xf4, 0xa3, 0xd8, 0x3d, 0x1c, 0xc8, 0x76, 0xce, 0xbf, 0x56, 0x00, 0x56,
	0x43, 0xdf, 0x0b, 0xe2, 0x55, 0x37, 0xf4, 0xd8, 0x4d, 0x28, 0x07, 0x5e, 0xb3, 0xf4, 0x7e, 0xe9,
	0x4e, 0x6d, 0x65, 0xfa, 0x97, 0xbf, 0xb8, 0x5d, 0xde, 0x58, 0xfb, 0x0f, 0xfc, 0x1f, 0x78, 0x1c,
	0xff, 0xd8, 0x12, 0x80, 0x92, 0xb5, 0x8d, 0x54, 0x65, 0xa2, 0x5a, 0x40, 0xaa, 0xda, 0xb2, 0x84,
	0x26, 0xc4, 0x35, 0x45, 0xb6, 0xe1, 0xb1, 0xbb, 0x50, 0xeb, 0xba, 0x51, 0xdc, 0x3e, 0xe8, 0x0f,
	0xc3, 0x66, 0x45, 0x32, 0x46, 0xaa, 0x49, 0x01, 0x7c, 0x82, 0x30, 0x9e, 0x94, 0x90, 0xfd, 0xb4,
	0xff, 0x76, 0x10, 0x84, 0xc7, 0x6d, 0x94, 0x34, 0x7e, 0xd5, 0x1c, 0x43, 0xea, 0xea, 0xca, 0x1c,
	0x52, 0x4f, 0x49, 0xf8, 0xa6, 0x00, 0x73, 0xb3, 0xc2, 0x1e, 0x80, 0xaa, 0xb6, 0x8f, 0x7d, 0x37,
	0x6c, 0x56, 0xa9, 0xc9, 0x2c, 0x36, 0x01, 0x09, 0xfe, 0x0a, 0xa1, 0xdc, 0x28, 0xe3, 0x1b, 0x8e,
	0xc5, 0xc7, 0x03, 0xbf, 0x39, 0x4e, 0xa2, 0x4c, 0x22, 0x25, 0xd5, 0x39, 0xfd, 0x67, 0x2b, 0x50,
	0xc5, 0xd1, 0x89, 0xfd, 0xe6, 0x04, 0xa2, 0x67, 0x97, 0x3e, 0x90, 0xa3, 0x74, 0x3f, 0x1d, 0x21,
	0xa3, 0xb8, 0x2b, 0x08, 0x57, 0x6a, 0xc8, 0x41, 0xb6, 0xe1, 0xf2, 0xc1, 0x96, 0x61, 0x9e, 0x0a,
	0x6d, 0xcf, 0x8f, 0x3a, 0x61, 0x30, 0x88, 0x83, 0x7e, 0xaf, 0x39, 0x49, 0xdd, 0x35, 0x90, 0xb8,
	0x4e, 0xc8, 0xb5, 0x14, 0xc7, 0x73, 0x10, 0x67, 0x1d, 0xe6, 0xac, 0x7e, 0xd8, 0x14, 0x4c, 0xec,
	0xf8, 0x3d, 0x2f, 0xe8, 0xbd, 0xac, 0x5f, 0x61, 0x00, 0xe3, 0xcb, 0x9d, 0x38, 0x38, 0xf2, 0xeb,
	0x25, 0x81, 0x58, 0x17, 0xaf, 0xe7, 0x7b, 0xf5, 0x32, 0x9b, 0x86, 0x49, 0xaa, 0x08, 0xb2, 0x8a,
	0xf3, 0x06, 0x16, 0x90, 0x0d, 0xb6, 0x4e, 0x99, 0x71, 0xff, 0x0d, 0xbb, 0x0d, 0xd5, 0xb8, 0xff,
	0xda, 0xef, 0xa9, 0x79, 0xa6, 0x37, 0x20, 0x00, 0x97, 0x0f, 0xf6, 0x69, 0xc1, 0x3c, 0xb7, 0xec,
	0x79, 0x4e, 0xe6, 0x78, 0xcd, 0x98, 0x6e, 0xe7, 0x29, 0x34, 0xf2, 0x5d, 0x46, 0x03, 0x9c, 0xa7,
	0xb1, 0x0e, 0x96, 0xa9, 0xcb, 0xa9, 0xa5, 0xf9, 0xdc, 0xb8, 0xca, 0x99, 0x10, 0x24, 0x9c, 0xfe,
	0x3b, 0x4f, 0xa0, 0xfe, 0xd4, 0x8f, 0xb3, 0x82, 0x67, 0xf5, 0xaf, 0x74, 0x16, 0xfd, 0x73, 0xd6,
	0x60, 0xde, 0xe2, 0xf3, 0x2e, 0xd2, 0xfc, 0x59, 0x09, 0xe6, 0x9e, 0x05, 0x51, 0xbc, 0x13, 0xf6,
	0xbd, 0x61, 0x27, 0x8e, 0x84, 0x34, 0x9f, 0xc1, 0x1c, 0x2e, 0xb1, 0xee, 0xd0, 0x13, 0x33, 0xdd,
	0xf5, 0x63, 0x5f, 0xf2, 0x9b, 0x5c, 0x61, 0xd8, 0x78, 0x56, 0xa1, 0xd6, 0x24, 0x86, 0x5b, 0x75,
	0xb3, 0xf1, 0x20, 0x0c, 0x8e, 0x84, 0xca, 0x95, 0x73, 0x8d, 0x77, 0x24, 0x86, 0x5b, 0x75, 0x67,
	0x15, 0xea, 0x59, 0x61, 0xe8, 0x95, 0xaa, 0x41, 0xec, 0x1f, 0x46, 0x28, 0x43, 0x05, 0xdf, 0x69,
	0x56, 0xbd, 0x93, 0xa2, 0x91, 0x93, 0x4c, 0x04, 0x5c, 0x3e, 0x9c, 0xff, 0xac, 0xa2, 0x46, 0x49,
	0xec, 0x29, 0xcb, 0x1e, 0x97, 0x4c, 0xcf, 0x3d, 0xf4, 0x95, 0x22, 0xd0, 0xd0, 0x88, 0x3a, 0xa7,
	0xff, 0x62, 0x05, 0x0e, 0x86, 0xfb, 0xdd, 0xa0, 0xd3, 0x26, 0x22, 0xb9, 0xc4, 0x69, 0x05, 0x4a,
	0xf0, 0x96, 0x20, 0x35, 0xca, 0xec, 0x13, 0x98, 0x32, 0x57, 0xc6, 0x18, 0x35, 0xa0, 0x55, 0x6e,
	0x80, 0xb9, 0x59, 0x61, 0x77, 0x60, 0xd2, 0x1b, 0x86, 0x2e, 0xd1, 0x4f, 0xd0, 0x12, 0x27, 0x1b,
	0xa2, 0x61, 0x3c, 0x29, 0x89, 0x71, 0xd5, 0xe5, 0xf6, 0xc0, 0x0f, 0x83, 0xbe, 0xa7, 0x96, 0x1e,
	0x8d, 0xab, 0x46, 0xed, 0x10, 0x86, 0x5b, 0x75, 0x5a, 0x18, 0x61, 0xe0, 0x76, 0x9b, 0x35, 0xea,
	0x43, 0x2e, 0x0c, 0x01, 0xe0, 0xf2, 0x21, 0x2c, 0x14, 0x15, 0x34, 0x6b, 0x48, 0x65, 0x27, 0xb8,
	0xe2, 0x6b, 0x56, 0x44, 0x9b, 0x81, 0x1c, 0xe6, 0x36, 0x19, 0x9e, 0xa9, 0xb4, 0x8d, 0x82, 0xef,
	0x09, 0xfb, 0x63, 0x56, 0xd8, 0x37, 0x61, 0x42, 0xab, 0xd4, 0x34, 0x69, 0xc5, 0x14, 0x92, 0x6b,
	0x10, 0xd7, 0x05, 0xe6, 0xc0, 0xb8, 0x1c, 0xd7, 0xe6, 0x0c, 0x51, 0x01, 0x52, 0x29, 0x08, 0x57,
	0x4f, 0xf6, 0x6d, 0x98, 0xf1, 0xdf, 0xc6, 0x7e, 0xd8, 0x43, 0xa9, 0xbb, 0x41, 0xef, 0x75, 0x73,
	0x96, 0xfa, 0xaf, 0x23, 0xe9, 0xb4, 0x46, 0x3c, 0x43, 0x38, 0xcf, 0xd4, 0x70, 0x92, 0x26, 0xe3,
	0x7e, 0x24, 0x5b, 0xcc, 0x51, 0x8b, 0x45, 0xd4, 0x8b, 0x89, 0xbd, 0xed, 0x5d, 0x81, 0x16, 0xd2,
	0x20, 0x9a, 0xda, 0xe9, 0x82, 0x18, 0xfa, 0x37, 0xc3, 0xa0, 0xf3, 0x1a, 0xad, 0x59, 0x18, 0xcb,
	0x96, 0xf5, 0x74, 0xe8, 0x53, 0x14, 0xb5, 0xb2, 0xea, 0x62, 0xe8, 0xfb, 0xa1, 0xe7, 0x87, 0xcd,
	0xf9, 0x74, 0xe8, 0x09, 0xc0, 0xe5, 0x83, 0x7d, 0x0f, 0x20, 0x14, 0x46, 0x75, 0xd0, 0x75, 0x7b,
	0x51, 0x93, 0x91, 0x92, 0xcf, 0x29, 0x25, 0xe7, 0x88, 0xd8, 0x41, 0xf8, 0xca, 0x8c, 0xb0, 0x4b,
	0xa1, 0xaa, 0x45, 0x3c, 0x2d, 0x3a, 0xff, 0x3d, 0x0e, 0x93, 0x9a, 0xec, 0xff, 0x95, 0xba, 0x57,
	0xcf, 0xab, 0xee, 0xe3, 0xe7, 0x57, 0xf7, 0x89, 0x33, 0xaa, 0xfb, 0xe4, 0x19, 0xd4, 0x3d, 0xd5,
	0xc9, 0xda, 0x48, 0x9d, 0xfc, 0x44, 0x8c, 0x61, 0xd8, 0x79, 0xe5, 0x46, 0xee, 0x7e, 0xd7, 0xa7,
	0x55, 0x34, 0xa9, 0x56, 0x44, 0x0a, 0xe6, 0x66, 0x45, 0x6c, 0x49, 0x7a, 0x15, 0xe1, 0xd4, 0x4d,
	0xa5, 0x5b, 0x92, 0x32, 0x61, 0x72, 0x4b, 0x1a, 0xe8, 0x0a, 0x4f, 0x8a, 0x1e, 0xfb, 0x7d, 0xb8,
	0xb1, 0x7f, 0x3c, 0x70, 0xa3, 0xa8, 0x3d, 0x70, 0x8f, 0x0f, 0x7d, 0xdc, 0x3c, 0x8e, 0x50, 0xd4,
	0x83, 0xa0, 0x23, 0x07, 0x58, 0x2e, 0xb0, 0xc7, 0xc8, 0xeb, 0xfa, 0x0a, 0x91, 0xed, 0x48, 0xaa,
	0x2f, 0x0c, 0x22, 0xe4, 0x7d, 0x7d, 0x7f, 0x14, 0x92, 0x8f, 0x46, 0xa5, 0x6a, 0x3d, 0x33, 0x42,
	0xad, 0x7f, 0x0c, 0x0c, 0xed, 0x7f, 0x07, 0xf7, 0xeb, 0x36, 0x7a, 0x68, 0x83, 0x7e, 0x0f, 0x39,
	0x44, 0xb8, 0x46, 0x85, 0x7a, 0x5f, 0x4b, 0x6c, 0x38, 0x11, 0xac, 0x6a, 0xfc, 0xca, 0x55, 0x64,
	0x33, 0x3f, 0xb0, 0xa0, 0x11, 0xcf, 0x83, 0xd8, 0x47, 0x00, 0x6f, 0x86, 0xee, 0x71, 0x3b, 0xf6,
	0x5d, 0xdc, 0x1a, 0xe6, 0x90, 0x6d, 0x4d, 0x2e, 0x12, 0x01, 0xdd, 0x13, 0x40, 0x9e, 0x16, 0xd9,
	0x1e, 0x34, 0x0f, 0xdc, 0xa0, 0xeb, 0x7b, 0xc9, 0x48, 0xed, 0xfb, 0xaf, 0xdc, 0xa3, 0x40, 0xb8,
	0x6e, 0x72, 0x29, 0xb7, 0xb0, 0xed, 0xa2, 0xa4, 0x51, 0xaf, 0xbb, 0xa2, 0x29, 0xf8, 0x08, 0xb8,
	0xf3, 0x2f, 0x15, 0xa8, 0xdb, 0xaf, 0xc0, 0x6e, 0x29, 0x37, 0xcc, 0x70, 0x41, 0x7e, 0xcb, 0xf0,
	0xc3, 0xe4, 0x0a, 0x2d, 0x9f, 0xb2, 0x42, 0x2b, 0x67, 0x59, 0xa1, 0x63, 0xe7, 0x5d, 0xa1, 0xd5,
	0x33, 0xac, 0xd0, 0xef, 0x43, 0xdd, 0xf3, 0x0f, 0xdc, 0x61, 0x37, 0x6e, 0xe3, 0xf0, 0xf5, 0xe2,
	0x20, 0x3e, 0xa6, 0x85, 0x57, 0x59, 0x59, 0xc0, 0x76, 0x73, 0x0a, 0xf7, 0x5c, 0xa1, 0xb8, 0x0d,
	0x10, 0x2b, 0xeb, 0x30, 0xe8, 0xa5, 0x6d, 0x27, 0xa8, 0x2d, 0xf5, 0x89, 0xf0, 0xa4, 0x9d, 0x59,
	0x41, 0x0b, 0x58, 0x8d, 0x03, 0x3f, 0x8c, 0x70, 0x19, 0x0a, 0xed, 0xb8, 0x39, 0x42, 0x3b, 0xf6,
	0x04, 0x8d, 0x5a, 0xcc, 0xa2, 0xc8, 0xe5, 0x83, 0x6d, 0xc3, 0xdc, 0xb0, 0x17, 0xc4, 0xed, 0xfe,
	0x41, 0xfb, 0xd0, 0x77, 0xa3, 0x61, 0xe8, 0xd3, 0x0a, 0x9d, 0x5a, 0x6a, 0x28, 0x46, 0x2f, 0x10,
	0xbb, 0x7d, 0xb0, 0x29, 0x71, 0x2b, 0xf3, 0xc8, 0x60, 0x66, 0x68, 0x82, 0x78, 0xb6, 0xea, 0xfc,
	0x71, 0x19, 0xae, 0x16, 0x76, 0x7e, 0x8a, 0x7d, 0x45, 0x9b, 0xd5, 0xed, 0x7f, 0xed, 0x87, 0xed,
	0xf8, 0x55, 0xe8, 0x47, 0xaf, 0xfa, 0x5d, 0x39, 0xd1, 0x15, 0x69, 0xb3, 0x08, 0xb5, 0xa7, 0x31,
	0xdc, 0xaa, 0x8b, 0xc6, 0xc3, 0xc1, 0x20, 0xd3, 0xb8, 0x92, 0x36, 0x26, 0x94, 0xd1, 0x38, 0x5b,
	0x97, 0x5b, 0xb1, 0x5c, 0x6c, 0xa4, 0x7c, 0x63, 0xe6, 0x56, 0x4c, 0x70, 0xbd, 0x15, 0x27, 0x15,
	0xb1, 0x82, 0x45, 0xd5, 0x27, 0xb5, 0x28, 0xc9, 0x71, 0x25, 0x00, 0x97, 0x0f, 0xe7, 0x0f, 0x61,
	0x26, 0x33, 0x72, 0x17, 0xda, 0x5d, 0x50, 0x42, 0x2f, 0x88, 0x70, 0x8f, 0x3b, 0xc6, 0x45, 0xe8,
	0x46, 0x4a, 0xc3, 0xa5, 0x2e, 0x6a, 0xf8, 0x72, 0xc4, 0xcd, 0x8a, 0xf3, 0x03, 0xe9, 0x9a, 0x6e,
	0xf4, 0x8e, 0xfa, 0x28, 0x0f, 0xb9, 0xa6, 0x1f, 0x15, 0x38, 0xca, 0x33, 0x19, 0x47, 0xd9, 0x74,
	0x91, 0xbf, 0x2f, 0xdd, 0xc9, 0x94, 0x01, 0xba, 0x93, 0xf7, 0x60, 0x32, 0x50, 0x75, 0xcb, 0xa3,
	0x54, 0x64, 0x3c, 0xc1, 0x3b, 0x9f, 0xc3, 0x0c, 0xba, 0xd8, 0x1a, 0x8e, 0xdd, 0x3f, 0x06, 0x50,
	0xc8, 0xb4, 0xfb, 0x1b, 0xa2, 0x7b, 0x45, 0x43, 0x03, 0x62, 0x90, 0xf0, 0x9a, 0x2a, 0xa3, 0x30,
	0x8f, 0x61, 0xd6, 0x64, 0x86, 0xa2, 0xdc, 0x81, 0x09, 0x85, 0x56, 0xfe, 0xba, 0x2d, 0x89, 0x46,
	0x3b, 0xff, 0x38, 0x0e, 0x13, 0x0a, 0x78, 0xa1, 0x59, 0xd8, 0x84, 0xb9, 0x68, 0xb8, 0x9f, 0xac,
	0x76, 0xf1, 0x12, 0x72, 0x22, 0x3e, 0x44, 0x46, 0xb3, 0xbb, 0x06, 0x8a, 0x98, 0xce, 0x46, 0x19,
	0x08, 0xcf, 0xd6, 0x3d, 0xeb, 0x38, 0x35, 0x76, 0x8e, 0xe3, 0x14, 0x63, 0xca, 0x4c, 0x92, 0x4d,
	0x52, 0xb6, 0xb1, 0xa1, 0xcf, 0xa8, 0xb4, 0xd3, 0xeb, 0x53, 0xa7, 0xd0, 0x6d, 0xda, 0x81, 0xdb,
	0xe4, 0x54, 0x91, 0x45, 0xd1, 0xba, 0x4d, 0xf0, 0x5d, 0x01, 0xe6, 0x66, 0x45, 0xa8, 0x89, 0x6a,
	0x83, 0x27, 0x4b, 0xb5, 0xbb, 0xd3, 0xee, 0x20, 0xa1, 0xeb, 0x3d, 0x9c, 0x99, 0xa4, 0xc8, 0x16,
	0x61, 0x3c, 0x88, 0xa2, 0x21, 0xfa, 0xa4, 0x35, 0xea, 0x58, 0xd5, 0x44, 0xcf, 0x7a, 0x2a, 0x3b,
	0xfd, 0x28, 0xa6, 0xed, 0xbc, 0x24, 0x7b, 0x56, 0xf0, 0x55, 0x04, 0x73, 0xb3, 0x62, 0xb6, 0x19,
	0xb8, 0x6a, 0x43, 0xcf, 0xb6, 0xd9, 0x41, 0x30, 0x37, 0x2b, 0xe4, 0xeb, 0x04, 0x91, 0x1c, 0x47,
	0xf7, 0x50, 0x3c, 0x68, 0xef, 0x2e, 0x29, 0x5f, 0x47, 0xa1, 0x96, 0x09, 0xc3, 0xad, 0x3a, 0x5b,
	0x87, 0x85, 0x1e, 0xce, 0xa4, 0x86, 0xe2, 0xea, 0x22, 0x59, 0x67, 0x88, 0x01, 0xed, 0xa7, 0x88,
	0x5e, 0x4b, 0xb0, 0x24, 0x71, 0x1e, 0x24, 0xec, 0xbe, 0xde, 0x1a, 0x43, 0xbf, 0xe3, 0xe3, 0x09,
	0xdc, 0x53, 0x0e, 0x35, 0xd9, 0x7d, 0x85, 0xe3, 0x0a, 0xc5, 0x6d, 0x80, 0x3c, 0xf6, 0x05, 0xb1,
	0xf0, 0xa9, 0xb4, 0x4e, 0xcf, 0x99, 0xc7, 0x3e, 0x42, 0x69, 0xbd, 0xb6, 0xea, 0x62, 0x7b, 0x8e,
	0xfb, 0x31, 0x36, 0xf5, 0xdf, 0xfa, 0x9d, 0x21, 0x69, 0xa6, 0x1b, 0xe3, 0x59, 0x6e, 0x80, 0x1e,
	0x43, 0x9d, 0xfc, 0x0b, 0xda, 0x9e, 0x89, 0x66, 0x5d, 0x93, 0x2c, 0x2b, 0x0a, 0x3e, 0x02, 0xce,
	0x5a, 0x30, 0xd9, 0x19, 0x86, 0xa1, 0xdf, 0xeb, 0x1c, 0x93, 0xf3, 0x5d, 0xe3, 0x49, 0xdd, 0xd9,
	0x06, 0x96, 0x2e, 0xc6, 0xe5, 0x68, 0x67, 0xed, 0x89, 0x58, 0xde, 0x9f, 0x16, 0x2c, 0xef, 0x96,
	0xbd, 0xbc, 0x93, 0x25, 0xbd, 0x66, 0xae, 0xee, 0x47, 0xb0, 0x90, 0x63, 0x88, 0x4b, 0xfc, 0x83,
	0x54, 0x1d, 0x3c, 0x37, 0x76, 0x89, 0xe7, 0x74, 0x32, 0xfb, 0x6b, 0x08, 0x72, 0x7e, 0x04, 0x33,
	0x32, 0xb0, 0xf0, 0x22, 0x42, 0xef, 0x09, 0xa5, 0xb8, 0x0b, 0xe3, 0x9e, 0xff, 0x36, 0x95, 0x80,
	0xa1, 0x04, 0xd5, 0x35, 0xff, 0x2d, 0xf5, 0x5e, 0xf5, 0x44, 0x81, 0xd3, 0x83, 0x1c, 0x5d, 0xff,
	0x10, 0x9d, 0x13, 0xb5, 0xdc, 0xc9, 0x86, 0x13, 0x80, 0xcb, 0x87, 0xf3, 0x19, 0xcc, 0x9a, 0xcc,
	0x51, 0xa2, 0xbb, 0x30, 0x36, 0xc4, 0xb2, 0xb2, 0x38, 0x53, 0x7a, 0x8b, 0x44, 0x90, 0xb4, 0x16,
	0x02, 0xc9, 0xe9, 0xbf, 0xf3, 0x1d, 0x00, 0x7c, 0xa7, 0xf3, 0x8b, 0x85, 0x83, 0x31, 0x95, 0x34,
	0x3c, 0x5f, 0x97, 0x3b, 0xb0, 0x20, 0x2c, 0xb6, 0xb2, 0x1f, 0x82, 0x24, 0x52, 0x13, 0x93, 0x33,
	0xfb, 0x67, 0x8c, 0xdb, 0x3c, 0x83, 0x46, 0x9e, 0x23, 0x0a, 0xf5, 0xad, 0x6c, 0x58, 0x61, 0xc1,
	0x90, 0x4a, 0xd0, 0x93, 0x74, 0xf9, 0xd8, 0xc2, 0x9f, 0x97, 0x60, 0x06, 0x27, 0x39, 0x48, 0x67,
	0x2b, 0x99, 0x82, 0x52, 0xf1, 0x14, 0x5c, 0x20, 0xe6, 0x84, 0xbc, 0xc7, 0xc2, 0x7e, 0x57, 0xba,
	0x83, 0xb3, 0xc9, 0xc0, 0x71, 0x04, 0x71, 0x42, 0x38, 0x75, 0x98, 0x35, 0xa5, 0x89, 0x06, 0xce,
	0x1e, 0x5c, 0x43, 0xbe, 0xfe, 0x80, 0x5e, 0x80, 0x70, 0xd2, 0x95, 0xbf, 0xd8, 0x20, 0xb6, 0xa0,
	0x59, 0xcc, 0x15, 0x7b, 0xfc, 0x6d, 0xb8, 0x21, 0x71, 0xcb, 0xdd, 0x6e, 0x16, 0x1d, 0x9d, 0x53,
	0x6d, 0xde, 0x83, 0x9b, 0xa3, 0x39, 0x61, 0x4f, 0xbf, 0x2a, 0x41, 0x8b, 0xfb, 0x47, 0xfd, 0xd7,
	0xf4, 0xba, 0x4a, 0x6a, 0xd1, 0x22, 0xa2, 0x9e, 0x5c, 0x58, 0xf4, 0xdf, 0xe2, 0xd4, 0x09, 0x2f,
	0xe8, 0xd0, 0x3f, 0xdc, 0x47, 0x5f, 0x2a, 0xd3, 0xf3, 0x47, 0xd8, 0xf3, 0xc2, 0xba, 0xa2, 0xd8,
	0x24, 0x02, 0x2d, 0xc7, 0xbc, 0x6e, 0x28, 0x18, 0x13, 0x90, 0x2f, 0xf8, 0x39, 0x4a, 0x8f, 0xad,
	0x00, 0x0b, 0x68, 0xbc, 0xbd, 0xb6, 0x50, 0xd7, 0xb6, 0xb9, 0xf8, 0x28, 0x04, 0xaa, 0xb0, 0x82,
	0xcd, 0x3a, 0x29, 0x41, 0x0e, 0x62, 0x4d, 0x43, 0xe5, 0x3c, 0xd3, 0xf0, 0xd7, 0x25, 0x98, 0x5f,
	0x7d, 0xe5, 0xf6, 0x5e, 0xca, 0xf9, 0x16, 0x7a, 0x70, 0x3e, 0x7b, 0xf1, 0xbf, 0xa9, 0x8b, 0x0d,
	0x60, 0xb6, 0x6c, 0x38, 0x67, 0xb7, 0xe0, 0xc6, 0xc8, 0x29, 0x43, 0xf4, 0x0f, 0xc9, 0xc3, 0x52,
	0xf0, 0x0b, 0x2a, 0xe9, 0x5f, 0x95, 0xc8, 0xc3, 0x4a, 0x98, 0xe1, 0x22, 0xff, 0x36, 0x4c, 0x28,
	0xbc, 0xe5, 0x61, 0x29, 0x22, 0x19, 0x7e, 0x52, 0x24, 0x5c, 0x17, 0xd8, 0x33, 0x98, 0x31, 0x3d,
	0x9d, 0x08, 0x47, 0xca, 0xb4, 0x11, 0xa6, 0x9f, 0x24, 0x8f, 0x13, 0x19, 0x6a, 0x9e, 0xad, 0x3a,
	0xf3, 0xd2, 0x8d, 0x55, 0x5d, 0x0a, 0x55, 0xd5, 0x71, 0xce, 0x14, 0x34, 0x3a, 0xce, 0xa9, 0x25,
	0xcd, 0xdb, 0xa2, 0x0d, 0xa8, 0x4b, 0xdb, 0x6e, 0x0c, 0xdf, 0xbb, 0xbd, 0x30, 0x4e, 0xc3, 0xbc,
	0xc5, 0xea, 0x9d, 0x07, 0xcf, 0xf9, 0x2e, 0xd4, 0x5f, 0x0c, 0x3c, 0x11, 0x91, 0x0a, 0xfb, 0x07,
	0x81, 0x54, 0x51, 0xf4, 0x74, 0x07, 0xb2, 0x66, 0xb1, 0xd2, 0x34, 0x1a, 0x2d, 0x24, 0xb1, 0x5a,
	0x4b, 0x49, 0x4e, 0x6c, 0x2e, 0x25, 0x19, 0xd8, 0xbc, 0xd2, 0x01, 0xf2, 0xbc, 0x50, 0x19, 0x09,
	0xf1, 0x52, 0xb2, 0x66, 0xbf, 0x94, 0x84, 0xaa, 0x97, 0x52, 0x0d, 0x74, 0xc1, 0x18, 0x20, 0xcd,
	0x4a, 0x0d, 0xd0, 0x3b, 0xf0, 0xda, 0xd0, 0x03, 0x74, 0x29, 0x62, 0x59, 0xac, 0x2e, 0x28, 0x16,
	0x2e, 0xd2, 0xf8, 0x92, 0xc4, 0xca, 0xb0, 0x7a, 0x77, 0xb1, 0x36, 0xa1, 0xce, 0xfd, 0x38, 0x08,
	0xfd, 0xcb, 0x31, 0x12, 0xe9, 0x5b, 0x5e, 0xc6, 0xa2, 0xb1, 0x58, 0xbd, 0xfb, 0xa2, 0x79, 0x0c,
	0xf3, 0xd6, 0x5b, 0x22, 0xaf, 0x6f, 0xc2, 0x44, 0x48, 0x40, 0x7d, 0xff, 0x42, 0x6d, 0x15, 0x88,
	0xeb, 0x82, 0x73, 0x00, 0xdf, 0x58, 0xed, 0xf7, 0x8e, 0x50, 0x90, 0x75, 0x15, 0xe8, 0xee, 0x1e,
	0x4b, 0x65, 0xf5, 0x0c, 0x9b, 0x73, 0x9e, 0x6d, 0xa2, 0x91, 0x71, 0x2b, 0xb5, 0x2f, 0xf9, 0xa7,
	0x25, 0xf8, 0xf0, 0xf4, 0x8e, 0x50, 0xee, 0x7d, 0xb8, 0xda, 0x91, 0x74, 0xe2, 0xac, 0x9f, 0x4c,
	0x94, 0xb4, 0x6c, 0xb5, 0x95, 0xfb, 0x62, 0x1f, 0x5e, 0xd5, 0x04, 0xc9, 0x94, 0x45, 0x28, 0xc6,
	0x42, 0x27, 0x0f, 0xe6, 0x79, 0xa0, 0x17, 0x39, 0x7f, 0x53, 0xa1, 0x4b, 0x1e, 0xb1, 0xce, 0x4f,
	0x39, 0x11, 0x5f, 0x60, 0xcf, 0xc3, 0xc3, 0x9c, 0x88, 0x5d, 0xba, 0xbd, 0x63, 0x33, 0x26, 0x4e,
	0x87, 0x39, 0x05, 0xa7, 0x90, 0x9b, 0x59, 0x49, 0xfd, 0xc1, 0xb1, 0x11, 0xfe, 0x20, 0x9e, 0x4d,
	0x0f, 0x82, 0x30, 0x8a, 0x25, 0xcb, 0x6a, 0x7a, 0x36, 0x25, 0x28, 0x31, 0x4c, 0x8b, 0xc9, 0x2d,
	0x33, 0x11, 0x8f, 0x67, 0x6f, 0x99, 0x89, 0x36, 0x29, 0x89, 0xe0, 0x7a, 0xd7, 0xed, 0x79, 0xdd,
	0xa0, 0xe7, 0xab, 0x43, 0xb2, 0xa2, 0x94, 0x30, 0x9e, 0x94, 0x44, 0x28, 0xfb, 0xb0, 0xbf, 0x2f,
	0xcc, 0xa9, 0x3c, 0x1a, 0x53, 0x28, 0x5b, 0x42, 0xb8, 0x7a, 0xe2, 0x81, 0xae, 0xa6, 0x96, 0xa0,
	0x1f, 0xe1, 0xb9, 0xb8, 0x52, 0xb0, 0x60, 0x49, 0xea, 0x84, 0x88, 0xa7, 0x45, 0xe7, 0x57, 0x38,
	0x3b, 0x8a, 0x0a, 0x4f, 0xd7, 0xe9, 0xec, 0x8c, 0xcb, 0xd9, 0xa1, 0x79, 0xf9, 0x16, 0x4c, 0xab,
	0x06, 0xcf, 0x50, 0xa6, 0x4f, 0xd4, 0xcc, 0xd0, 0xf5, 0x8d, 0x09, 0xe7, 0x99, 0x9a, 0xd5, 0x6a,
	0x49, 0x4d, 0x89, 0xdd, 0x6a, 0x29, 0xd3, 0x6a, 0xc9, 0x6a, 0xf5, 0x50, 0xcd, 0x8d, 0xdd, 0xea,
	0x61, 0xa6, 0xd5, 0x43, 0x11, 0x4b, 0xe9, 0x88, 0x18, 0x66, 0x35, 0x8d, 0xa5, 0x88, 0x3a, 0xa7,
	0xff, 0x62, 0xb8, 0x71, 0x38, 0x8e, 0x82, 0x5e, 0x27, 0x33, 0x31, 0x1a, 0xc6, 0x93, 0x92, 0x58,
	0xc7, 0xa4, 0x51, 0xe1, 0xb1, 0x9a, 0x17, 0x5a, 0xc7, 0x0a, 0xc4, 0x75, 0x81, 0x18, 0xe2, 0x51,
	0xbc, 0xd3, 0xf7, 0xf4, 0xbc, 0x48, 0x86, 0x0a, 0xc6, 0x93, 0x52, 0x66, 0xa6, 0x6b, 0x27, 0xce,
	0xb4, 0xbc, 0x5d, 0x10, 0xab, 0x44, 0x28, 0x3f, 0x64, 0x6e, 0x17, 0x04, 0x34, 0xb9, 0x5d, 0x90,
	0x15, 0x9e, 0x14, 0xe9, 0x44, 0x3f, 0x08, 0x83, 0x43, 0x37, 0x3c, 0x6e, 0x6b, 0xbb, 0x3d, 0x95,
	0x9e, 0xe8, 0x15, 0x4a, 0x1b, 0x78, 0xab, 0xee, 0xfc, 0xbc, 0x8c, 0x0a, 0xa0, 0xbc, 0xa9, 0x93,
	0x97, 0xa7, 0xb1, 0xb7, 0x97, 0xcf, 0xbe, 0xb7, 0xb3, 0x8f, 0x61, 0x82, 0xe2, 0xff, 0x89, 0x0b,
	0xdd, 0x40, 0xce, 0xe3, 0xcf, 0x11, 0x44, 0xdc, 0xc7, 0xdf, 0x50, 0x89, 0xcb, 0xa7, 0xc7, 0x9e,
	0x43, 0xbd, 0xe7, 0x7f, 0x1d, 0x75, 0xfd, 0x38, 0x4e, 0xdc, 0xf6, 0x31, 0x7a, 0x9b, 0x5f, 0xc3,
	0x76, 0x73, 0x5b, 0x09, 0x8e, 0x7c, 0x74, 0x11, 0xf1, 0xe8, 0x65, 0x41, 0xdc, 0x06, 0x98, 0x57,
	0x99, 0xd5, 0x13, 0xae, 0x32, 0x7f, 0x00, 0xd0, 0x91, 0x36, 0xb2, 0xed, 0xc6, 0xa4, 0x28, 0xe2,
	0x5e, 0x5e, 0x26, 0xad, 0xdc, 0xdf, 0xd3, 0x49, 0x2b, 0x72, 0x2d, 0x29, 0xc2, 0xe5, 0x98, 0xa7,
	0x45, 0xe7, 0x1f, 0xea, 0x30, 0x6d, 0x7a, 0x9c, 0xa7, 0x5c, 0x21, 0xe0, 0x8c, 0xa3, 0xb1, 0x8c,
	0x32, 0xd1, 0x3d, 0x9a, 0xf1, 0x2f, 0x24, 0x54, 0xce, 0xf8, 0x91, 0xae, 0xf0, 0xa4, 0x78, 0xa1,
	0x70, 0x5e, 0xf6, 0x16, 0xab, 0x7a, 0x9e, 0x5b, 0xac, 0x1f, 0x41, 0x43, 0x37, 0x4d, 0xee, 0x41,
	0x05, 0x13, 0xb9, 0xa6, 0xee, 0x21, 0x93, 0x79, 0xc5, 0x44, 0x5f, 0x73, 0xca, 0x23, 0xdb, 0xc0,
	0x06, 0xf2, 0x1c, 0x28, 0x0d, 0x87, 0x4e, 0x14, 0x86, 0x43, 0x3f, 0xd5, 0x01, 0xc7, 0x49, 0x3a,
	0xd4, 0x34, 0x0b, 0xfc, 0xfb, 0x73, 0xe5, 0xc2, 0xd4, 0xce, 0x93, 0x0b, 0xc3, 0xb6, 0x60, 0x56,
	0xb2, 0x88, 0x7c, 0x71, 0x6f, 0x87, 0x86, 0x06, 0x48, 0x0c, 0x7d, 0x6d, 0x41, 0x5d, 0xef, 0x2a,
	0x9c, 0x3a, 0x67, 0x98, 0x20, 0x9e, 0xad, 0x8a, 0x81, 0x94, 0xf1, 0xad, 0xb8, 0x9d, 0x09, 0x98,
	0x4e, 0x8d, 0xd2, 0xb9, 0x45, 0x64, 0xc9, 0x54, 0x93, 0x1d, 0x23, 0x94, 0x5a, 0x00, 0x63, 0x2f,
	0x80, 0x59, 0xcc, 0x45, 0x64, 0x75, 0x7a, 0x14, 0x6b, 0x1a, 0x83, 0x0c, 0x1b, 0x11, 0x73, 0xcd,
	0x41, 0x84, 0xcc, 0x3a, 0x6c, 0x98, 0x91, 0x79, 0xe6, 0x44, 0x99, 0x55, 0x93, 0x8c, 0xcc, 0x79,
	0x18, 0xfb, 0x2e, 0xd4, 0xe4, 0x2d, 0xaf, 0x10, 0x75, 0x76, 0x14, 0x47, 0x32, 0x9d, 0x44, 0x27,
	0x44, 0x4c, 0x4a, 0xc2, 0x64, 0x64, 0x62, 0xe5, 0x82, 0xc9, 0xdc, 0x28, 0x26, 0x14, 0x24, 0x35,
	0xc9, 0x05, 0x2f, 0x1b, 0xc0, 0x3e, 0x87, 0x59, 0xf4, 0x65, 0xe2, 0xd0, 0x45, 0x5d, 0x97, 0xef,
	0x59, 0x1f, 0xc5, 0x90, 0xa6, 0x5b, 0x13, 0xcb, 0x57, 0xcc, 0x56, 0xd9, 0x1a, 0xb0, 0x68, 0x48,
	0x27, 0xe9, 0x83, 0xa1, 0x1e, 0xbd, 0x48, 0x65, 0x19, 0x50, 0xdc, 0x37, 0xc5, 0xca, 0x41, 0x89,
	0x78, 0x1e, 0x24, 0xb2, 0x28, 0x64, 0xe8, 0x55, 0x33, 0x60, 0xc4, 0x80, 0xb6, 0x46, 0x42, 0xe8,
	0xb6, 0x99, 0x1a, 0x7b, 0x84, 0x6f, 0x42, 0x49, 0x45, 0x38, 0x2c, 0xe2, 0x1a, 0xdb, 0x6b, 0x2e,
	0x90, 0x0d, 0x94, 0x62, 0x13, 0x66, 0x5d, 0x22, 0x78, 0xb6, 0xaa, 0xec, 0xbd, 0x58, 0xa6, 0xcd,
	0x86, 0x6d, 0xef, 0x29, 0xa1, 0x47, 0xdb, 0x7b, 0x5a, 0xc9, 0xba, 0xc0, 0x1e, 0x43, 0x2d, 0xb1,
	0x0e, 0xcd, 0xab, 0xd4, 0x30, 0x97, 0x24, 0x41, 0x33, 0xa9, 0x33, 0x23, 0x78, 0x52, 0x12, 0xd7,
	0xa0, 0xee, 0xcb, 0x97, 0xa1, 0xff, 0xd2, 0x15, 0xf1, 0x9c, 0xe6, 0x62, 0x7a, 0x2b, 0x6f, 0x80,
	0xb9, 0x59, 0x61, 0x2b, 0xea, 0x7a, 0xe2, 0x1a, 0xad, 0xc8, 0x0f, 0x0b, 0x0c, 0x43, 0xa6, 0x22,
	0x2e, 0xd4, 0x72, 0x29, 0x77, 0xc2, 0x9c, 0x22, 0x47, 0x34, 0xfc, 0x71, 0x3f, 0x6a, 0x36, 0xa9,
	0x57, 0x69, 0x4e, 0x09, 0xba, 0xb7, 0xbd, 0x4b, 0xe6, 0x54, 0x57, 0xb8, 0x2e, 0xf6, 0x23, 0xb6,
	0x0b, 0xd3, 0x3a, 0x1a, 0x4f, 0x62, 0x5c, 0x27, 0x31, 0x6e, 0x17, 0x89, 0xa1, 0x6e, 0xa5, 0x49,
	0x02, 0x79, 0x29, 0x92, 0x02, 0xb8, 0x59, 0x61, 0x3f, 0x3e, 0x39, 0x5d, 0xa0, 0x45, 0x02, 0xde,
	0x7a, 0xe7, 0x8c, 0x00, 0x5c, 0x2f, 0x1d, 0x8a, 0xff, 0x74, 0xfb, 0x2f, 0xe5, 0x0e, 0x1b, 0x35,
	0x6f, 0xa4, 0x5b, 0xec, 0xaa, 0xc6, 0xd1, 0xee, 0x29, 0x9c, 0xfd, 0xb9, 0x4e, 0x16, 0xc4, 0x6d,
	0x00, 0x0b, 0xa1, 0x99, 0xcb, 0x21, 0x68, 0x1f, 0xb9, 0xdd, 0x21, 0xba, 0xa4, 0x37, 0x4f, 0xbc,
	0x2b, 0xfe, 0x42, 0x10, 0xc9, 0x5b, 0x83, 0x41, 0x11, 0x2a, 0xe2, 0x23, 0xe0, 0x27, 0xa6, 0x0a,
	0xdc, 0x7a, 0xe7, 0x54, 0x81, 0xa7, 0x30, 0x65, 0x4c, 0x94, 0x48, 0x6d, 0x7c, 0xd1, 0x7b, 0xdd,
	0xeb, 0x7f, 0xdd, 0xab, 0x5f, 0x61, 0xf3, 0x30, 0xb3, 0x23, 0x13, 0x42, 0xfc, 0x6d, 0x91, 0x3a,
	0x51, 0x2f, 0xb1, 0x59, 0x33, 0x77, 0xb5, 0x5e, 0x66, 0x93, 0x30, 0xb6, 0x85, 0x42, 0xd6, 0x2b,
	0xe2, 0x4a, 0xd3, 0x56, 0x3c, 0x56, 0x83, 0xea, 0x9e, 0xb0, 0x5a, 0xc8, 0xcb, 0xf2, 0x15, 0x90,
	0xd5, 0x0c, 0xd4, 0x9e, 0x04, 0x6f, 0x51, 0xad, 0xfc, 0xf0, 0xb0, 0x5e, 0x76, 0x7e, 0x52, 0xcd,
	0xdf, 0x6d, 0xd3, 0x9b, 0xb3, 0xdf, 0x15, 0xfb, 0xb0, 0x3d, 0xd8, 0x89, 0xa3, 0x21, 0x82, 0xa7,
	0xcc, 0x6e, 0x48, 0x1b, 0x31, 0x1b, 0xe4, 0xa0, 0x3c, 0x0f, 0xf3, 0x70, 0xbb, 0x5b, 0xcc, 0xf3,
	0x37, 0x8e, 0x55, 0x4d, 0xe4, 0xd5, 0xb0, 0xdb, 0xd1, 0x11, 0xa7, 0x10, 0x2a, 0x0e, 0x5a, 0xa4,
	0x0a, 0xe4, 0xa8, 0x54, 0xe4, 0x16, 0x4d, 0x00, 0x2e, 0x1f, 0xec, 0x8f, 0x4a, 0x45, 0x3d, 0x06,
	0xbd, 0x83, 0x3e, 0x39, 0x28, 0x53, 0x4b, 0x9f, 0x9c, 0xa4, 0x3c, 0x39, 0xe8, 0x06, 0x36, 0x2c,
	0x16, 0x52, 0x60, 0x78, 0x21, 0xb4, 0xf5, 0xb3, 0x32, 0x34, 0x8a, 0x18, 0xd9, 0xb9, 0x1c, 0xa5,
	0xf3, 0xe6, 0x72, 0x94, 0xcf, 0x90, 0xcb, 0xf1, 0x39, 0x5c, 0xc5, 0xb7, 0xf5, 0x71, 0xcb, 0xf5,
	0xda, 0x07, 0x61, 0xff, 0xb0, 0xad, 0x92, 0x35, 0x68, 0xc0, 0x27, 0x57, 0xae, 0x89, 0x03, 0xb7,
	0x26, 0x78, 0x82, 0xf8, 0x35, 0x89, 0xe6, 0x45, 0xc0, 0xa2, 0x2c, 0x8b, 0xb1, 0x0b, 0x65, 0x59,
	0xdc, 0x87, 0x9a, 0x88, 0x12, 0x4b, 0xe5, 0xfb, 0x40, 0x4f, 0x66, 0x29, 0x1f, 0x5e, 0x96, 0x18,
	0xe7, 0xa7, 0x65, 0x18, 0x13, 0x41, 0xe4, 0xcb, 0xbc, 0x1f, 0x43, 0xa5, 0xd4, 0x49, 0xea, 0x6d,
	0x11, 0xc4, 0x16, 0x79, 0x09, 0x66, 0x82, 0x92, 0xe8, 0x4f, 0x47, 0x6e, 0x84, 0x2c, 0xea, 0xc8,
	0x98, 0x02, 0x70, 0x5f, 0x34, 0x6b, 0xad, 0x1e, 0x4c, 0x19, 0xe4, 0x17, 0x08, 0x54, 0xb1, 0x0f,
	0x55, 0xbc, 0x5d, 0x1e, 0x8a, 0xea, 0xc6, 0x80, 0xd0, 0x88, 0xa9, 0xa0, 0xfb, 0x9f, 0x94, 0x60,
	0xda, 0xbc, 0xb2, 0xba, 0xd4, 0xc1, 0xb9, 0x3b, 0x32, 0xe4, 0x2f, 0xf7, 0xba, 0x30, 0x0d, 0xfe,
	0xff, 0xa4, 0x04, 0x4d, 0x5b, 0xcf, 0x93, 0xfc, 0x1e, 0xf4, 0x95, 0x73, 0xeb, 0x50, 0x89, 0x47,
	0x7e, 0xa2, 0xbd, 0x72, 0x78, 0x0e, 0x22, 0x4e, 0xbc, 0x49, 0x4a, 0x91, 0xcc, 0xa9, 0xa1, 0xcd,
	0x5e, 0xc3, 0x78, 0x52, 0x72, 0xfe, 0x19, 0x0d, 0x9c, 0x0c, 0x4a, 0x99, 0x86, 0xf0, 0x62, 0x51,
	0x43, 0xeb, 0x78, 0x53, 0xbe, 0x8c, 0xe3, 0x4d, 0xe5, 0x32, 0x8e, 0x37, 0x59, 0x17, 0x63, 0xec,
	0x3c, 0x2e, 0x46, 0xd1, 0x76, 0x5d, 0xbd, 0xd8, 0x76, 0xfd, 0x3b, 0x96, 0xd7, 0x32, 0x4e, 0x7a,
	0x73, 0x27, 0x4d, 0x42, 0xcf, 0x4f, 0xca, 0x39, 0xdc, 0x97, 0x4f, 0xb3, 0x5f, 0x30, 0x9c, 0xe7,
	0xb0, 0x86, 0x3b, 0xc1, 0xcd, 0xfc, 0x4e, 0xa0, 0x54, 0x26, 0xf0, 0x75, 0xe2, 0xd9, 0xed, 0x11,
	0xfb, 0x81, 0x56, 0xe4, 0x95, 0xf7, 0x90, 0x73, 0x6b, 0x50, 0x8c, 0x45, 0x36, 0xfc, 0x04, 0x9c,
	0xf3, 0x38, 0xeb, 0x01, 0xe4, 0x36, 0xfd, 0x2b, 0xd6, 0xa6, 0x5f, 0x4a, 0x36, 0xfd, 0xb2, 0xf3,
	0x1c, 0x16, 0x8b, 0x46, 0x2f, 0x1a, 0xb0, 0xef, 0xc0, 0xb4, 0x79, 0xc8, 0x50, 0x31, 0xe7, 0xa2,
	0x8b, 0x2a, 0x9e, 0x21, 0x74, 0xfe, 0xbe, 0x84, 0xcb, 0xc4, 0xed, 0x75, 0xfc, 0xae, 0xbd, 0x4c,
	0x0a, 0x72, 0x84, 0x4a, 0x97, 0x96, 0x23, 0x74, 0xae, 0xf0, 0xab, 0x03, 0xe3, 0xf8, 0xd6, 0x11,
	0xbe, 0x56, 0x25, 0x0d, 0x53, 0x4a, 0x08, 0x57, 0x4f, 0xa7, 0x89, 0x43, 0x53, 0xf0, 0x1a, 0xd1,
	0xc0, 0xf9, 0xbb, 0x12, 0x5c, 0x7b, 0xd1, 0xeb, 0xfc, 0xdf, 0x7e, 0x47, 0x71, 0xb3, 0x5e, 0x2c,
	0x24, 0xbe, 0xc1, 0x5f, 0x94, 0x64, 0xee, 0xc2, 0x6e, 0xe6, 0x76, 0xf1, 0x62, 0x96, 0xcc, 0xf8,
	0x3c, 0x43, 0xdf, 0x2d, 0xe4, 0x3f, 0xcf, 0xe0, 0xea, 0x8a, 0xc1, 0xaa, 0x3b, 0x7f, 0x89, 0x4a,
	0x53, 0x20, 0x10, 0xe9, 0xe1, 0xf8, 0xc0, 0x0d, 0xfd, 0xe4, 0xd6, 0xa3, 0xf0, 0xaa, 0x54, 0x66,
	0x4c, 0x13, 0x19, 0x57, 0x4f, 0xf6, 0x3d, 0x98, 0xec, 0xbc, 0x0a, 0xba, 0x1e, 0x56, 0x4e, 0xba,
	0x65, 0x25, 0x6b, 0xaf, 0x09, 0x79, 0x52, 0x72, 0xfe, 0x16, 0x25, 0xda, 0xf5, 0xc5, 0x3a, 0x13,
	0x37, 0x11, 0x1e, 0x72, 0x44, 0x3f, 0xf8, 0xa2, 0x63, 0x64, 0xc4, 0x16, 0xcb, 0x67, 0x88, 0x2d,
	0xde, 0xd2, 0xa9, 0xc8, 0xf4, 0xe9, 0x11, 0xa9, 0xaa, 0xca, 0x3d, 0x16, 0x00, 0xa1, 0xa1, 0x45,
	0x12, 0xe2, 0xfc, 0x72, 0xb8, 0xfa, 0xf4, 0x92, 0x65, 0x77, 0x0e, 0x60, 0xf1, 0x69, 0x61, 0x6f,
	0xe6, 0x5b, 0x95, 0xce, 0xfd, 0x56, 0x65, 0xfb, 0xad, 0x36, 0x60, 0x5a, 0xdc, 0xb5, 0x47, 0x91,
	0x1f, 0x5f, 0x54, 0xe4, 0x9f, 0x96, 0x64, 0x12, 0x80, 0xe2, 0x85, 0xa2, 0x3e, 0x82, 0x71, 0x97,
	0x6a, 0xea, 0x2e, 0xfc, 0x7d, 0xa5, 0x12, 0x19, 0xaa, 0xfb, 0xb2, 0xb8, 0x4e, 0x41, 0x74, 0x45,
	0xdf, 0xc2, 0x73, 0x96, 0x01, 0xc6, 0xe3, 0x50, 0xe5, 0xb5, 0x7f, 0x2c, 0xc5, 0xe1, 0xa2, 0x88,
	0x36, 0x45, 0x39, 0x9a, 0xd2, 0xaf, 0x9a, 0xd6, 0x57, 0x1a, 0xa2, 0x91, 0xf2, 0x34, 0x1f, 0x97,
	0x1f, 0x95, 0x84, 0xf5, 0xa8, 0x12, 0x50, 0x5c, 0x86, 0x75, 0xdd, 0x7d, 0x5f, 0x25, 0xf8, 0x70,
	0x59, 0x61, 0x0f, 0x61, 0xe2, 0xa0, 0x1f, 0x1e, 0xba, 0xb1, 0x4e, 0x0e, 0xb8, 0x6e, 0x72, 0xba,
	0xff, 0x44, 0xe2, 0xa4, 0x70, 0x9a, 0xb2, 0xb5, 0x0d, 0xd3, 0x26, 0xa2, 0x40, 0xbc, 0xbb, 0x59,
	0xf1, 0xf4, 0x5a, 0xd8, 0x1e, 0xc6, 0x83, 0x61, 0x2c, 0xdb, 0x9a, 0x52, 0xfe, 0x1e, 0x4c, 0x9b,
	0xa8, 0x11, 0xb2, 0x36, 0x4c, 0xa6, 0x35, 0x7d, 0x3c, 0xd2, 0x19, 0x98, 0x15, 0x23, 0x03, 0xb3,
	0x05, 0x93, 0x22, 0xba, 0x9e, 0xa6, 0x97, 0xf3, 0xa4, 0x2e, 0x2e, 0x62, 0xe5, 0x26, 0xf4, 0x2c,
	0xe8, 0xf8, 0xbd, 0xc8, 0xbf, 0xe0, 0xac, 0x2f, 0xe8, 0x1b, 0xf5, 0x84, 0x1d, 0xae, 0x88, 0x1d,
	0xca, 0xa2, 0x53, 0x8d, 0xc5, 0x6e, 0x3e, 0xbc, 0xa8, 0x72, 0xfd, 0xa2, 0x02, 0x8d, 0x3c, 0x4b,
	0x79, 0xb9, 0xba, 0xef, 0x76, 0x85, 0xe1, 0x25, 0x86, 0x25, 0x19, 0x77, 0x52, 0x20, 0xae, 0x0b,
	0xb8, 0x53, 0x8c, 0x47, 0xd4, 0x88, 0x06, 0x6f, 0x76, 0xe9, 0xae, 0xa1, 0x8a, 0x36, 0xcf, 0xfb,
	0x19, 0x88, 0x34, 0x77, 0xb2, 0x31, 0x57, 0x4f, 0x0a, 0xda, 0x51, 0x29, 0x13, 0x37, 0x96, 0xdb,
	0x9b, 0x0c, 0xda, 0x11, 0xd6, 0x0c, 0x1c, 0xe7, 0x41, 0xcc, 0x87, 0xf9, 0x9e, 0xff, 0x36, 0x6e,
	0x1b, 0xa9, 0x85, 0xfa, 0x34, 0x56, 0x10, 0x4a, 0x54, 0x37, 0x1c, 0x6f, 0x75, 0x76, 0xe2, 0x1a,
	0x52, 0xcb, 0x1b, 0x8e, 0x0c, 0x88, 0xdb, 0x00, 0x71, 0x8f, 0xab, 0xbe, 0x54, 0x11, 0xd1, 0x90,
	0xc4, 0xff, 0x15, 0x7e, 0x62, 0x72, 0x8f, 0xab, 0x9d, 0x18, 0x2f, 0xf1, 0x84, 0xe9, 0x1e, 0x77,
	0x90, 0x07, 0xf3, 0x3c, 0xd0, 0x13, 0x39, 0xde, 0x33, 0x99, 0x51, 0x13, 0x5e, 0xcf, 0xd3, 0xed,
	0xed, 0x35, 0xf4, 0x87, 0x1a, 0x50, 0x5f, 0xfe, 0x72, 0x79, 0x63, 0x6f, 0x63, 0xeb, 0x69, 0x7b,
	0x67, 0xf9, 0xab, 0xcd, 0xf5, 0xad, 0x3d, 0x19, 0x1a, 0x59, 0x5b, 0x7f, 0xb6, 0xb1, 0xf5, 0xfc,
	0x85, 0xa8, 0x97, 0x85, 0xca, 0x88, 0xd0, 0x46, 0xd0, 0xcb, 0x26, 0xc2, 0x5c, 0x40, 0x65, 0x16,
	0xa1, 0x91, 0xe7, 0x88, 0xca, 0x39, 0x84, 0xf9, 0x65, 0xef, 0x48, 0x68, 0xc5, 0xa5, 0xf4, 0x23,
	0x34, 0x50, 0x07, 0x5d, 0xcb, 0x14, 0x74, 0x95, 0x91, 0x4f, 0x15, 0x6f, 0xd5, 0x05, 0x91, 0x57,
	0x65, 0x77, 0x1b, 0x0d, 0xee, 0x6d, 0xc2, 0x4c, 0xe6, 0x7e, 0x80, 0x42, 0x4a, 0x5b, 0x9f, 0x6f,
	0x6d, 0x7f, 0xb9, 0x25, 0x3f, 0xa3, 0xdd, 0xda, 0xe6, 0x9b, 0xcb, 0xcf, 0xa4, 0x1b, 0x49, 0x03,
	0x5a, 0x16, 0x24, 0x5f, 0x2e, 0xf3, 0x2d, 0x1c, 0xcf, 0x7a, 0x45, 0x7c, 0x50, 0xbb, 0xca, 0x71,
	0x70, 0x57, 0x91, 0x68, 0xec, 0xde, 0x6f, 0xc0, 0x18, 0x1d, 0x58, 0x67, 0xf0, 0x50, 0xbe, 0xbe,
	0xbc, 0xd6, 0xde, 0xde, 0x7a, 0xf6, 0x15, 0xf2, 0xa9, 0xa1, 0x11, 0x5c, 0xdb, 0xdc, 0xd8, 0x92,
	0xe3, 0xbe, 0xfb, 0x62, 0x67, 0x9d, 0xb7, 0x5f, 0xec, 0xae, 0xf3, 0x7a, 0xf9, 0xde, 0x1d, 0xa8,
	0x91, 0xa9, 0xd3, 0xf1, 0x2c, 0xb5, 0x8c, 0xa5, 0x1f, 0xbb, 0x33, 0xec, 0x76, 0x77, 0xfd, 0x0e,
	0x7a, 0x18, 0xf5, 0xd2, 0xbd, 0xd7, 0x30, 0x9f, 0x73, 0xd2, 0xd9, 0x1c, 0xba, 0xc3, 0xe2, 0x7e,
	0x54, 0x5c, 0x3d, 0xf9, 0x1e, 0xb6, 0x42, 0x31, 0x45, 0x32, 0x34, 0xf6, 0xb4, 0x00, 0x73, 0xcb,
	0x5f, 0xbb, 0x81, 0x88, 0xc3, 0x2a, 0x8f, 0x19, 0x65, 0x47, 0xc1, 0xa4, 0x9f, 0xd7, 0x45, 0xea,
	0x8a, 0x78, 0xc1, 0x27, 0x14, 0x69, 0xab, 0x8f, 0x99, 0xdf, 0x09, 0x57, 0x97, 0xfe, 0xab, 0x01,
	0xb3, 0x5a, 0xa1, 0xfc, 0xf0, 0x48, 0x64, 0x17, 0x7f, 0x46, 0x7e, 0xb5, 0xca, 0x81, 0x65, 0x8d,
	0xcc, 0x71, 0x44, 0x65, 0x71, 0xb6, 0xae, 0x16, 0x40, 0x71, 0xca, 0xaf, 0xb0, 0x25, 0x98, 0x50,
	0xa9, 0xac, 0x6c, 0x3e, 0x5d, 0xfa, 0xba, 0x19, 0xb3, 0x41, 0xd4, 0x06, 0x3b, 0x4c, 0xb3, 0x32,
	0x93, 0x0e, 0x33, 0x69, 0xa3, 0x49, 0x87, 0x56, 0xfa, 0xe6, 0x15, 0xf6, 0x15, 0x34, 0x8a, 0x52,
	0x2d, 0xd9, 0x7b, 0x69, 0x1e, 0x49, 0x51, 0x76, 0x67, 0xeb, 0xf6, 0x89, 0x78, 0x62, 0xed, 0xeb,
	0x2c, 0xce, 0x7c, 0x7e, 0x25, 0x73, 0x32, 0xcd, 0x0b, 0x53, 0x39, 0x5b, 0xdf, 0x38, 0x95, 0x86,
	0xba, 0xd9, 0x87, 0x6b, 0x23, 0x52, 0xfe, 0x98, 0xfe, 0xec, 0x7c, 0x74, 0x16, 0x67, 0xcb, 0x39,
	0x8d, 0x84, 0xfa, 0x78, 0x0a, 0xb3, 0xd9, 0x64, 0x43, 0xa6, 0xcf, 0x83, 0xb9, 0xfc, 0xc8, 0xd6,
	0xf5, 0x11, 0x18, 0x62, 0xb4, 0x99, 0xc9, 0xc4, 0xa3, 0xf4, 0x60, 0xd6, 0x52, 0x0d, 0x0a, 0x32,
	0x91, 0x5b, 0x37, 0x46, 0xe2, 0xf4, 0xd4, 0xa7, 0x3b, 0x43, 0x32, 0xf5, 0x99, 0x14, 0xc7, 0x64,
	0xea, 0xb3, 0xb9, 0x8a, 0xd8, 0x78, 0x19, 0xa6, 0xcd, 0xac, 0x40, 0xb6, 0x98, 0xef, 0x8b, 0x64,
	0xb8, 0x56, 0x08, 0x27, 0x16, 0x6b, 0x3a, 0x99, 0x5c, 0x8b, 0x70, 0x2d, 0xa3, 0xd8, 0x86, 0x14,
	0xcd, 0x62, 0x84, 0xe6, 0x92, 0xc9, 0x46, 0x4a, 0xb8, 0xd8, 0x99, 0x58, 0x09, 0x97, 0x5c, 0xf2,
	0x92, 0xe4, 0x92, 0xc9, 0x8f, 0x4a, 0xb8, 0xd8, 0x09, 0x58, 0x09, 0x97, 0x5c, 0x3a, 0x95, 0x9c,
	0x20, 0x7b, 0xaf, 0x4d, 0x26, 0xa8, 0xc0, 0x57, 0x48, 0x26, 0xa8, 0x68, 0x83, 0x96, 0xec, 0x6c,
	0xe3, 0x9e, 0xb0, 0x2b, 0xd8, 0x47, 0x12, 0x76, 0x85, 0x3b, 0x02, 0xe9, 0x61, 0xd6, 0x38, 0x27,
	0x7a, 0x98, 0xdb, 0x2a, 0x12, 0x3d, 0xcc, 0x5b, 0x73, 0x3d, 0x58, 0x46, 0xde, 0xa3, 0x31, 0x58,
	0xd9, 0x5c, 0x4a, 0x63, 0xb0, 0xac, 0x34, 0xc9, 0xcc, 0xf4, 0xab, 0xe4, 0x1b, 0x6b, 0xfa, 0x93,
	0xcc, 0x3e, 0x7b, 0xfa, 0xd3, 0x3c, 0x3d, 0x53, 0x16, 0x9b, 0x8b, 0x9d, 0xb6, 0x68, 0xc9, 0x52,
	0xc0, 0xc5, 0x48, 0x02, 0xb4, 0xa7, 0xbf, 0x88, 0x8b, 0x95, 0x33, 0x28, 0xe7, 0xcb, 0xfe, 0xd9,
	0x85, 0x64, 0xbe, 0x0a, 0x7e, 0x02, 0x22, 0x99, 0xaf, 0xa2, 0xdf, 0x6a, 0x90, 0x42, 0x65, 0x7e,
	0x34, 0x21, 0x11, 0xca, 0xfe, 0x49, 0x86, 0x44, 0xa8, 0xdc, 0x6f, 0x2c, 0x20, 0x97, 0x1d, 0x98,
	0xcf, 0x1d, 0x83, 0x99, 0x69, 0x19, 0xec, 0x13, 0x7b, 0xeb, 0xe6, 0x68, 0x24, 0x71, 0xdc, 0x05,
	0x96, 0x8f, 0xf0, 0xb0, 0x9b, 0x27, 0x85, 0xce, 0x5a, 0xb7, 0x4e, 0xc0, 0x26, 0x4c, 0x73, 0x91,
	0x85, 0x94, 0x69, 0x51, 0x64, 0x24, 0x65, 0x5a, 0x1c, 0x92, 0xa0, 0xfd, 0xa9, 0x28, 0x60, 0x91,
	0xec, 0x4f, 0x23, 0x42, 0x2e, 0xc9, 0xfe, 0x34, 0x32, 0xda, 0xa1, 0x8d, 0xa7, 0xfe, 0x28, 0xc8,
	0x30, 0x9e, 0xe9, 0x17, 0x78, 0xa6, 0xf1, 0x34, 0x3e, 0xa5, 0x4b, 0x8d, 0xa7, 0xfe, 0xd6, 0x2f,
	0x63, 0x3c, 0x8d, 0x2f, 0x08, 0x33, 0xc6, 0xd3, 0xfc, 0x30, 0x10, 0x59, 0xfc, 0x10, 0xe6, 0xac,
	0x6f, 0x78, 0xd8, 0xf5, 0x5c, 0x77, 0xfa, 0x63, 0xa1, 0x56, 0x6b, 0x14, 0xca, 0x14, 0x47, 0xff,
	0x92, 0x45, 0x46, 0x1c, 0xe3, 0xb7, 0x36, 0x32, 0xe2, 0x98, 0x3f, 0x7b, 0x21, 0xa7, 0x2f, 0x7f,
	0x94, 0x4f, 0xa6, 0xaf, 0x30, 0x72, 0x90, 0x4c, 0x5f, 0x71, 0x0c, 0x40, 0x32, 0xdd, 0x1d, 0xcd,
	0x74, 0xf7, 0x44, 0xa6, 0xbb, 0xa3, 0x98, 0xfe, 0x01, 0xbc, 0x7f, 0x5a, 0x62, 0x28, 0xbb, 0xa7,
	0x15, 0xeb, 0xf4, 0x54, 0xd5, 0xd6, 0xaf, 0x9f, 0x99, 0x36, 0x6b, 0xf5, 0x94, 0x0f, 0x6a, 0x59,
	0xbd, 0xf4, 0xbc, 0x6a, 0x59, 0x3d, 0xf3, 0xe4, 0x79, 0x85, 0x3d, 0x82, 0x5a, 0x12, 0x5f, 0x60,
	0x0b, 0xf9, 0x88, 0xc3, 0x9b, 0x56, 0xa3, 0x28, 0x0c, 0xe1, 0x5c, 0x59, 0xa9, 0xff, 0xfc, 0x97,
	0xef, 0x95, 0xfe, 0x09, 0xff, 0xfe, 0x0d, 0xff, 0x7e, 0xf6, 0xef, 0xef, 0x5d, 0xd9, 0x1f, 0x27,
	0xc2, 0x87, 0xff, 0x13, 0x00, 0x00, 0xff, 0xff, 0xe5, 0xbc, 0x3b, 0x05, 0x02, 0x49, 0x00, 0x00,
}
